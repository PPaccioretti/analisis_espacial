[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Análisis Espacial",
    "section": "",
    "text": "Resumen TBD\n\nObjetivos\nGeneral:\n\nbla\n\nEspecíficos:\n\nbla\nbla\n\n\n\nContenidos\n\nUnidad 1.\nUnidad 2.\nUnidad 3.\nUnidad 4.\nUnidad 5."
  },
  {
    "objectID": "lc_index.html",
    "href": "lc_index.html",
    "title": "Lectura complementaria",
    "section": "",
    "text": "El material que se presenta en esta sección fue traducido y recortado del libro “Geocomputation with R” de Robin Lovelace, Jakub Nowosad y Jannes Muenchow.\n\nDatos espaciales en R\nOperaciones con atributos\nOperaciones espaciales\nOperaciones con geometrías\nInteracción raster-vector\nReproyección de datos espaciales\nEntrada y salida de datos espaciales\nHaciendo mapas en R"
  },
  {
    "objectID": "lc_index.html#quarto",
    "href": "lc_index.html#quarto",
    "title": "Lectura complementaria",
    "section": "",
    "text": "Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "lc_index.html#running-code",
    "href": "lc_index.html#running-code",
    "title": "Lectura complementaria",
    "section": "Running Code",
    "text": "Running Code\nWhen you click the Render button a document will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n1 + 1\n## [1] 2\n\nYou can add options to executable code like this\n\n## [1] 4\n\nThe echo: false option disables the printing of code (only output is displayed)."
  },
  {
    "objectID": "operaciones_con_atributos.html",
    "href": "operaciones_con_atributos.html",
    "title": "Operaciones con atributos",
    "section": "",
    "text": "Los atributos son la información no espacial asociada a la información geográfica o geometría."
  },
  {
    "objectID": "operaciones_con_atributos.html#vectores",
    "href": "operaciones_con_atributos.html#vectores",
    "title": "Operaciones con atributos",
    "section": "Vectores",
    "text": "Vectores\n\nmethods(class = \"sf\") # methods for sf objects\n##   [1] [                            [[&lt;-                        \n##   [3] $&lt;-                          aggregate                   \n##   [5] anti_join                    arrange                     \n##   [7] as.data.frame                cbind                       \n##   [9] coerce                       crs                         \n##  [11] dbDataType                   dbWriteTable                \n##  [13] distance                     distinct                    \n##  [15] dplyr_reconstruct            duplicated                  \n##  [17] ext                          extract                     \n##  [19] filter                       full_join                   \n##  [21] group_by                     group_split                 \n##  [23] identify                     initialize                  \n##  [25] inner_join                   left_join                   \n##  [27] lines                        mask                        \n##  [29] merge                        mutate                      \n##  [31] plot                         points                      \n##  [33] polys                        print                       \n##  [35] rasterize                    rbind                       \n##  [37] rename_with                  rename                      \n##  [39] right_join                   rowwise                     \n##  [41] sample_frac                  sample_n                    \n##  [43] select                       semi_join                   \n##  [45] show                         slice                       \n##  [47] slotsFromS3                  st_agr                      \n##  [49] st_agr&lt;-                     st_area                     \n##  [51] st_as_s2                     st_as_sf                    \n##  [53] st_as_sfc                    st_bbox                     \n##  [55] st_boundary                  st_break_antimeridian       \n##  [57] st_buffer                    st_cast                     \n##  [59] st_centroid                  st_collection_extract       \n##  [61] st_concave_hull              st_convex_hull              \n##  [63] st_coordinates               st_crop                     \n##  [65] st_crs                       st_crs&lt;-                    \n##  [67] st_difference                st_drop_geometry            \n##  [69] st_filter                    st_geometry                 \n##  [71] st_geometry&lt;-                st_inscribed_circle         \n##  [73] st_interpolate_aw            st_intersection             \n##  [75] st_intersects                st_is_valid                 \n##  [77] st_is                        st_join                     \n##  [79] st_line_merge                st_m_range                  \n##  [81] st_make_valid                st_minimum_rotated_rectangle\n##  [83] st_nearest_points            st_node                     \n##  [85] st_normalize                 st_point_on_surface         \n##  [87] st_polygonize                st_precision                \n##  [89] st_reverse                   st_sample                   \n##  [91] st_segmentize                st_set_precision            \n##  [93] st_shift_longitude           st_simplify                 \n##  [95] st_snap                      st_sym_difference           \n##  [97] st_transform                 st_triangulate_constrained  \n##  [99] st_triangulate               st_union                    \n## [101] st_voronoi                   st_wrap_dateline            \n## [103] st_write                     st_z_range                  \n## [105] st_zm                        summarise                   \n## [107] svc                          tmapGetShapeMeta1           \n## [109] tmapGetShapeMeta2            tmapShape                   \n## [111] tmapSubsetShp                transform                   \n## [113] transmute                    ungroup                     \n## [115] vect                        \n## see '?methods' for accessing help and source code\n\nCon los objetos sf también se pueden utilizar los métodos de tidyverse para data.frame, tbl_df y tbl. De este modo, sf permite explotar las capacidades de análisis de datos de R en los datos geográficos, tanto si se utilizan las funciones básicas de R como las de tidyverse para el análisis de datos.\n\nclass(world) \ndim(world)\n## [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n## [1] 177  11\n\nLa función st_drop_geometry() conserva únicamente los atributos de un objeto sf, es decir, elimina su geometría.\n\nworld_df = st_drop_geometry(world)\nclass(world_df)\nncol(world_df)\n## [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n## [1] 10\n\nPara muchas aplicaciones, el paquete tidyverse dplyr ofrece un enfoque eficaz para trabajar con los data frames. La compatibilidad con tidyverse es una ventaja de sf.\nSubdivisión de vectores vía sus atributos\nLos métodos de subdivisión básicos de R incluyen el operador [ y la función subset(), mientras que en el paquete dplyr, éstas son son filter() y slice() para filas, y select() para columnas. Ambos métodos conservan los componentes espaciales de los datos en los objetos sf, mientras que si se utiliza el operador $ o la función dplyr pull() para devolver una única columna de atributos como vector, se perderán los datos geométricos.\n\nworld[1:6, ]    # subset rows by position\nworld[, 1:3]    # subset columns by position\nworld[1:6, 1:3] # subset rows and columns by position\nworld[, c(\"name_long\", \"pop\")] # columns by name\nworld[, c(T, T, F, F, F, F, F, T, T, F, F)] # by logical indices\nworld[, 888] # an index representing a non-existent column\n\nPodemos usar vectores lógicos para seleccionar subconjuntos de datos:\n\ni_small = world$area_km2 &lt; 10000\nsummary(i_small) # a logical vector\nsmall_countries = world[i_small, ]\n##    Mode   FALSE    TRUE \n## logical     170       7\n\no más sencillamente:\n\nsmall_countries = world[world$area_km2 &lt; 10000, ]\n\nLa función subset() nos permite realizar la misma operación:\n\nsmall_countries = subset(world, area_km2 &lt; 10000)\n\nLas funciones de R base son maduras, estables y ampliamente utilizadas, lo que las convierte en una opción sólida, especialmente en contextos en los que la reproducibilidad y la fiabilidad son fundamentales. Las funciones de dplyr por su parte permiten flujos de trabajo “ordenados” o tidy que algunas personas consideran intuitivos y productivos para el análisis interactivo de datos. A continuación se muestran las funciones clave para hacer subset de data.frames con funciones dplyr.\n\nselect()\n\n\nworld1 = select(world, name_long, pop)\nnames(world1)\n## [1] \"name_long\" \"pop\"       \"geom\"\n\n\n# all columns between name_long and pop (inclusive)\nworld2 = select(world, name_long:pop)\n\n\n\n- operator\n\n\n# all columns except subregion and area_km2 (inclusive)\nworld3 = select(world, -subregion, -area_km2)\n\n\n\nselect(): subset and rename\n\n\nworld4 = select(world, name_long, population = pop)\n\nselect() también funciona con “funciones de ayuda” para operaciones de subset más avanzadas, como contains(), starts_with() y num_range().\nLa mayoría de los verbos dplyr devuelven un data.frame, pero también se puede extraer una sola columna como un vector con pull(). Se puede obtener el mismo resultado en R base con los operadores $ y [[, los tres comandos siguientes devuelven el mismo vector numérico:\n\npull(world, pop)\nworld$pop\nworld[[\"pop\"]]\n\n\n\nslice() es el equivalente en filas de select(). El siguiente fragmento de código, por ejemplo, selecciona las filas 1 a 6:\n\n\nslice(world, 1:6)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\niso_a2\nname_long\ncontinent\nregion_un\nsubregion\ntype\narea_km2\npop\nlifeExp\ngdpPercap\ngeom\n\n\n\nFJ\nFiji\nOceania\nOceania\nMelanesia\nSovereign country\n19289.97\n885806\n69.96000\n8222.254\nMULTIPOLYGON (((-180 -16.55…\n\n\nTZ\nTanzania\nAfrica\nAfrica\nEastern Africa\nSovereign country\n932745.79\n52234869\n64.16300\n2402.099\nMULTIPOLYGON (((33.90371 -0…\n\n\nEH\nWestern Sahara\nAfrica\nAfrica\nNorthern Africa\nIndeterminate\n96270.60\nNA\nNA\nNA\nMULTIPOLYGON (((-8.66559 27…\n\n\nCA\nCanada\nNorth America\nAmericas\nNorthern America\nSovereign country\n10036042.98\n35535348\n81.95305\n43079.143\nMULTIPOLYGON (((-132.71 54….\n\n\nUS\nUnited States\nNorth America\nAmericas\nNorthern America\nCountry\n9510743.74\n318622525\n78.84146\n51921.985\nMULTIPOLYGON (((-171.7317 6…\n\n\nKZ\nKazakhstan\nAsia\nAsia\nCentral Asia\nSovereign country\n2729810.51\n17288285\n71.62000\n23587.338\nMULTIPOLYGON (((87.35997 49…\n\n\n\n\n\n\n\n\nfilter() es el equivalente de dplyr a la función subset() de R base. Mantiene sólo las filas que coinciden con los criterios dados, por ejemplo, sólo los países con un área por debajo de un cierto umbral, o con un alto promedio de esperanza de vida:\n\n\nworld7 = filter(world, area_km2 &lt; 10000)  # countries with a small area\nworld7 = filter(world, lifeExp &gt; 82)      # with high life expectancy\n\nLa clave de los flujos de trabajo que utilizan funciones dplyr es el operador ‘pipe’ %&gt;% (o desde R 4.1.0 la tubería nativa |&gt;), que toma su nombre del pipe de Unix |. Los pipes permiten un código expresivo: la salida de una función se convierte en el primer argumento de la siguiente función, permitiendo el encadenamiento. Esto se ilustra a continuación donde sólo se filtran los países de Asia del conjunto de datos world, a continuación el objeto se subdivide por columnas (nombre_largo y continente) y se extraen las cinco primeras filas.\n\nworld7 = world |&gt;\n  filter(continent == \"Asia\") |&gt;\n  select(name_long, continent) |&gt;\n  slice(1:5)\n\nLo de arriba puede también expresarse como funciones anidadas, aunque es más difícil de leer:\n\nworld8 = slice(\n  select(\n    filter(world, continent == \"Asia\"),\n    name_long, continent),\n  1:5)\n\nAgregación de atributos vectoriales\nLa agregación consiste en resumir los datos con una o varias “variables de agrupación”, normalmente a partir de columnas de la tabla de datos que se desea agregar. Un ejemplo de agregación de atributos es calcular el número de personas por continente a partir de datos a nivel de país (una fila por país). El conjunto de datos world contiene los ingredientes necesarios: las columnas pop y continent, la población y la variable de agrupación, respectivamente. El objetivo es hallar la sum() de las poblaciones de los países para cada continente, lo que da como resultado un data.frame más pequeño. Esto se puede hacer con la función base de R aggregate() de la siguiente manera:\n\nworld_agg1 = aggregate(pop ~ continent, FUN = sum, data = world, na.rm = TRUE)\nclass(world_agg1)\nhead(world_agg1)\n## [1] \"data.frame\"\n\n\n\n\ncontinent\npop\n\n\n\nAfrica\n1154946633\n\n\nAsia\n4311408059\n\n\nEurope\n669036256\n\n\nNorth America\n565028684\n\n\nOceania\n37757833\n\n\nSouth America\n412060811\n\n\n\n\n\n\naggregate() es una función genérica lo que significa que se comporta de forma diferente dependiendo de sus entradas. sf proporciona el método aggregate.sf() que se activa automáticamente cuando x es un objeto sf y se proporciona un argumento by:\n\nworld_agg2 = aggregate(world[\"pop\"], list(world$continent), \n                       FUN = sum, \n                       na.rm = TRUE)\nclass(world_agg2)\nnrow(world_agg2)\n## [1] \"sf\"         \"data.frame\"\n## [1] 8\n\nEl objeto resultante world_agg2 es un objeto espacial que contiene 8 características que representan los continentes del mundo.\nLa función group_by() |&gt; summarize() es el equivalente dplyr de aggregate(), con el nombre de la variable proporcionada en la función group_by() especificando la variable de agrupación y la información sobre lo que se va a resumir pasada a la función summarize(), como se muestra a continuación:\n\nworld_agg3 = world |&gt;\n  group_by(continent) |&gt;\n  summarize(pop = sum(pop, na.rm = TRUE))\n\nEste enfoque puede parecer más complejo, pero tiene ventajas: flexibilidad, legibilidad y control sobre los nuevos nombres de las columnas. Esta flexibilidad se ilustra en el comando siguiente, que calcula no sólo la población, sino también la superficie y el número de países de cada continente:\n\nworld_agg4  = world |&gt; \n  group_by(continent) |&gt; \n  summarize(Pop = sum(pop, na.rm = TRUE), Area = sum(area_km2), N = n())\n\nEn el trozo de código anterior Pop, Area y N son nombres de columnas en el resultado, y sum() y n() las funciones de agregación. Estas funciones de agregación devuelven objetos sf con filas que representan continentes y geometrías que contienen los múltiples polígonos que representan cada masa de tierra y las islas asociadas (esto funciona gracias a la operación geométrica union, como se explica más abajo.\nCombinemos lo que hemos aprendido hasta ahora sobre las funciones dplyr, encadenando múltiples comandos para resumir datos de atributos sobre países de todo el mundo por continentes. El siguiente comando calcula la densidad de población (con mutate()), ordena los continentes por el número de países que contienen (con dplyr::arrange()), y mantiene sólo los 3 continentes más poblados (con dplyr::slice_max()):\n\nworld_agg5 = world |&gt; \n  st_drop_geometry() |&gt;                      # drop the geometry for speed\n  select(pop, continent, area_km2) |&gt; # subset the columns of interest  \n  group_by(continent) |&gt;                     # group by continent and summarize:\n  summarize(Pop = sum(pop, na.rm = TRUE), Area = sum(area_km2), N = n()) |&gt;\n  mutate(Density = round(Pop / Area)) |&gt;     # calculate population density\n  slice_max(Pop, n = 3) |&gt;                   # keep only the top 3\n  arrange(desc(N))                           # arrange in order of n. countries\n\n\noptions(scipen = 999)\nknitr::kable(\n  world_agg5,\n  caption = \"The top 3 most populous continents ordered by number of countries.\",\n  caption.short = \"Top 3 most populous continents.\",\n  booktabs = TRUE\n)\n\n\nThe top 3 most populous continents ordered by number of countries.\n\ncontinent\nPop\nArea\nN\nDensity\n\n\n\nAfrica\n1154946633\n29946198\n51\n39\n\n\nAsia\n4311408059\n31252459\n47\n138\n\n\nEurope\n669036256\n23065219\n39\n29\n\n\n\n\n\nUnión de atributos vectoriales\nCombinar datos de distintas fuentes es una tarea habitual en la preparación de datos. Las uniones lo hacen combinando tablas basadas en una variable “clave” o key compartida. dplyr tiene múltiples funciones de unión, incluyendo left_join() y inner_join() — ver vignette(\"two-table\") para una lista completa. Los nombres de estas funciones siguen las convenciones utilizadas en el lenguaje de bases de datos SQL; su uso para unir conjuntos de datos no espaciales a objetos sf es el objetivo de esta sección. Las funciones join de dplyr funcionan igual en data.frames y objetos sf, la única diferencia importante es la columna geometry. El resultado de las uniones de datos puede ser un objeto sf o un data.frame. El tipo más común de unión de atributos en datos espaciales toma un objeto sf como primer argumento y le añade columnas de un data.frame especificado como segundo argumento.\nPara demostrar las uniones, combinaremos datos sobre la producción de café con el conjunto de datos world. Los datos sobre el café se encuentran en un data.frame denominado coffee_data del paquete spData. Tiene 3 columnas: name_long nombra las principales naciones productoras de café y coffee_production_2016 y coffee_production_2017 contienen valores estimados para la producción de café en bolsas de 60 kg en cada año. Un “left join”, que conserva el primer conjunto de datos, combina “world” con “coffee_data”:\n\nworld_coffee = left_join(world, coffee_data)\nclass(world_coffee)\n## [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n\nDado que los conjuntos de datos de entrada comparten una “key” (name_long), la unión funcionó sin utilizar el argumento by (véase ?left_join para más detalles). El resultado es un objeto sf idéntico al objeto world original, pero con dos nuevas variables (con índices de columna 11 y 12) sobre la producción de café. Esto puede representarse como un mapa, tal y como se ilustra en la Figura (fig:coffeemap), generada con la función plot() que se muestra a continuación:\n\nnames(world_coffee)\nplot(world_coffee[\"coffee_production_2017\"])\n\n\n\nWorld coffee production (thousand 60-kg bags) by country, 2017. Source: International Coffee Organization.\n\n\n##  [1] \"iso_a2\"                 \"name_long\"              \"continent\"             \n##  [4] \"region_un\"              \"subregion\"              \"type\"                  \n##  [7] \"area_km2\"               \"pop\"                    \"lifeExp\"               \n## [10] \"gdpPercap\"              \"geom\"                   \"coffee_production_2016\"\n## [13] \"coffee_production_2017\"\n\nPara que la unión funcione, se debe proporcionar una columna “key” en ambos conjuntos de datos. Por defecto, dplyr utiliza todas las variables con nombres coincidentes. En este caso, los objetos world_coffee y world contienen una variable llamada name_long, lo que explica el mensaje Joining withby = join_by(name_long)``. En la mayoría de los casos en los que los nombres de las variables no coinciden, hay dos opciones:\n\nCambiar el nombre de la variable clave en uno de los objetos para que coincidan.\nUtilizar el argumento by para especificar las variables de unión.\n\nEste último enfoque se demuestra a continuación en una versión renombrada de coffee_data:\n\ncoffee_renamed = rename(coffee_data, nm = name_long)\nworld_coffee2 = left_join(world, coffee_renamed, by = join_by(name_long == nm))\n\nObserve que se mantiene el nombre en el objeto original, lo que significa que world_coffee y el nuevo objeto world_coffee2 son idénticos. Otra característica del resultado es que tiene el mismo número de filas que el conjunto de datos original. Aunque sólo hay 47 filas de datos en coffee_data, los 177 registros de países se mantienen intactos en world_coffee y world_coffee2: A las filas del conjunto de datos original que no coinciden se les asignan valores NA para las nuevas variables de producción de café. ¿Qué ocurre si sólo queremos conservar los países que tienen una coincidencia en la variable key?\nEn ese caso, se puede utilizar una unión interna:\n\nworld_coffee_inner = inner_join(world, coffee_data)\nnrow(world_coffee_inner)\n## [1] 45\n\nObserve que el resultado de inner_join() sólo tiene 45 filas frente a las 47 de coffee_data. ¿Qué ha pasado con las filas restantes? Podemos identificar las filas que no coinciden utilizando la función setdiff() de la siguiente manera:\n\nsetdiff(coffee_data$name_long, world$name_long)\n## [1] \"Congo, Dem. Rep. of\" \"Others\"\n\nEl resultado muestra que Otros representa una fila que no está presente en el conjunto de datos world y que el nombre de la Democratic Republic of the Congo representa la otra: se ha abreviado, lo que hace que la unión no lo encuentre. El siguiente comando utiliza una función de concordancia de cadenas (regex) del paquete stringr para confirmar cuál debería ser Congo, Rep. Dem. of debería ser:\n\ndrc = stringr::str_subset(world$name_long, \"Dem*.+Congo\")\ndrc\n## [1] \"Democratic Republic of the Congo\"\n\n\n# aim: test names in coffee_data and world objects\nstringr::str_subset(coffee_data$name_long, \"Ivo|Congo,\")\n.Last.value %in% stringr::str_subset(world$name_long, \"Ivo|Dem*.+Congo\")\n## [1] \"Congo, Dem. Rep. of\" \"Côte d'Ivoire\"      \n## logical(0)\n\nPara solucionar este problema, crearemos una nueva versión de coffee_data y actualizaremos el nombre. Si unimos el data.frame actualizado con inner_join(), obtendremos un resultado con las 46 naciones productoras de café:\n\ncoffee_data$name_long[grepl(\"Congo,\", coffee_data$name_long)] = drc\nworld_coffee_match = inner_join(world, coffee_data)\nnrow(world_coffee_match)\n## [1] 46\n\nTambién es posible unir en la otra dirección: empezar con un conjunto de datos no espaciales y añadir variables de un objeto sf. Esto se demuestra a continuación, se comienza con el objeto coffee_data y se añaden variables del conjunto de datos world. En contraste con las uniones anteriores, el resultado no es un sf, sino un data.frame en forma de tidyverse tibble: el resultado de una unión tiende a coincidir con su primer argumento:\n\ncoffee_world = left_join(coffee_data, world)\nclass(coffee_world)\n## [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n\n\n\n\n\nNota\n\n\n\nEn la mayoría de los casos, la columna de geometría sólo es útil en un objeto sf. La columna de geometría sólo se puede utilizar para crear mapas y operaciones espaciales si R “sabe” que es un objeto espacial, definido por un paquete espacial como sf. Afortunadamente, los marcos de datos no espaciales con una columna de lista de geometría (como coffee_world) pueden coaccionarse en un objeto sf de la siguiente manera: st_as_sf(coffee_world).\n\n\nCreación de atributos y eliminación de información espacial\nA menudo, nos gustaría crear una nueva columna basada en columnas ya existentes. Por ejemplo, queremos calcular la densidad de población de cada país. Para ello necesitamos dividir una columna de población, aquí pop, por una columna de área, aquí area_km2 con unidad de área en kilómetros cuadrados. Usando R base, podemos escribir:\n\nworld_new = world # do not overwrite our original data\nworld_new$pop_dens = world_new$pop / world_new$area_km2\n\nAlternativamente, podemos utilizar una de las funciones de dplyr - mutate() o transmute(). La función mutate() añade nuevas columnas en la penúltima posición del objeto sf (la última se reserva para la geometría):\n\nworld_new2 = world |&gt; \n  mutate(pop_dens = pop / area_km2)\n\nLa diferencia entre mutate() y transmute() es que esta última elimina todas las demás columnas existentes (excepto la columna de geometría).\nLa función unite() del paquete tidyr (que proporciona muchas funciones útiles para remodelar conjuntos de datos, incluida pivot_longer()) pega las columnas existentes. Por ejemplo, queremos combinar las columnas continent y region_un en una nueva columna llamada con_reg. Además, podemos definir un separador (aquí: dos puntos :) que define cómo deben unirse los valores de las columnas de entrada, y si deben eliminarse las columnas originales (aquí: TRUE):\n\nworld_unite = world |&gt;\n  tidyr::unite(\"con_reg\", continent:region_un, sep = \":\", remove = TRUE)\n\nEl objeto sf resultante tiene una nueva columna llamada con_reg que representa el continente y la región de cada país, por ejemplo South America:Americas para Argentina y otros países de Sudamérica.\nLa función separate() de tidyr hace lo contrario que unite(): divide una columna en varias columnas utilizando una expresión regular o posiciones de caracteres.\n\nworld_separate = world_unite |&gt;\n  tidyr::separate(con_reg, c(\"continent\", \"region_un\"), sep = \":\")\n\nCada una de estas operaciones de datos de atributos conserva la geometría de las características simples. A veces tiene sentido eliminar la geometría, por ejemplo para acelerar la agregación. Hágalo con st_drop_geometry(), no manualmente con comandos como select(world, -geom), como se muestra a continuación.1\n\nworld_data = world |&gt; st_drop_geometry()\nclass(world_data)\n## [1] \"tbl_df\"     \"tbl\"        \"data.frame\""
  },
  {
    "objectID": "operaciones_con_atributos.html#raster",
    "href": "operaciones_con_atributos.html#raster",
    "title": "Operaciones con atributos",
    "section": "Raster",
    "text": "Raster\nA diferencia del modelo de datos vectoriales subyacente a sf (que representa puntos, líneas y polígonos como entidades discretas en el espacio), los datos ráster representan superficies continuas. Esta sección muestra cómo funcionan los objetos ráster creándolos desde cero con el paquete terra. Debido a su estructura única, la subdivisión o subset y otras operaciones en conjuntos de datos ráster funcionan de una manera diferente.\nEl siguiente código recrea el conjunto de datos ráster utilizado en el apartado anterior. Esto demuestra cómo funciona la función rast() para crear un raster de ejemplo llamado elev.\n\nelev = rast(nrows = 6, ncols = 6,\n            xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n            vals = 1:36)\n\nEl resultado es un objeto raster con 6 filas y 6 columnas (especificadas por los argumentos nrow y ncol), y una extensión espacial mínima y máxima en dirección x e y (xmin, xmax, ymin, ymax). El argumento vals establece los valores que contiene cada celda.\nLos objetos raster también pueden contener valores categóricos de la clase logical o variables factor:\n\ngrain_order = c(\"clay\", \"silt\", \"sand\")\ngrain_char = sample(grain_order, 36, replace = TRUE)\ngrain_fact = factor(grain_char, levels = grain_order)\ngrain = rast(nrows = 6, ncols = 6, \n             xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n             vals = grain_fact)\n\nEl objeto ráster almacena la correspondiente tabla de consulta o “Raster Attribute Table” (RAT) como una lista de data.frames, que pueden visualizarse con cats(grain) (véase ?cats() para más información). Cada elemento de esta lista es una capa del raster. También es posible utilizar la función levels() para recuperar y añadir nuevos niveles de factor o sustituir los existentes:\n\nlevels(grain) = data.frame(value = c(0, 1, 2), wetness = c(\"wet\", \"moist\", \"dry\"))\nlevels(grain)\n## [[1]]\n##   value wetness\n## 1     0     wet\n## 2     1   moist\n## 3     2     dry\n\n\n\n\n\nRaster datasets with numeric (left) and categorical values (right).\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nLos objetos ráster categóricos también pueden almacenar información sobre los colores asociados a cada valor utilizando una tabla de colores. La tabla de colores es un marco de datos con tres (rojo, verde, azul) o cuatro (alfa) columnas, donde cada fila se refiere a un valor. Las tablas de color en terra pueden verse o establecerse con la función coltab() (ver ?coltab). Es importante destacar que, al guardar un objeto ráster con una tabla de colores en un archivo (por ejemplo, GeoTIFF), también se guardará la información de color.\n\n\nRaster subsetting\nEl subconjunto raster se realiza con el operador base de R [, que acepta una variedad de entradas:\n\nIndexación fila-columna\nID de celda\nCoordenadas\nOtro objeto espacial\n\nAquí sólo mostramos las dos primeras opciones, ya que pueden considerarse operaciones no espaciales. Si necesitamos un objeto espacial para subdividir otro o la salida es un objeto espacial, nos referiremos a esto como subset espacial. Por lo tanto, estas dos últimas opciones se mostrarán en el próximo capítulo.\nLas dos primeras opciones de subconjunto se muestran en los siguientes comandos — ambos devuelven el valor del píxel superior izquierdo en el objeto ráster elev:\n\n# row 1, column 1\nelev[1, 1]\n# cell ID 1\nelev[1]\n\nSubdividir objetos ráster multicapa devolverá los valores de las celdas de cada capa. Por ejemplo, two_layers = c(grain, elev); two_layers[1] devuelve un marco de datos con una fila y dos columnas — una para cada capa. Para extraer todos los valores o filas completas, también puede utilizar values().\nLos valores de las celdas pueden modificarse sobrescribiendo los valores existentes junto con una operación de subconjunto. El siguiente fragmento de código, por ejemplo, establece la celda superior izquierda de elev a 0:\n\nelev[1, 1] = 0\nelev[]\n\nDejar los corchetes vacíos es una versión abreviada de values() para recuperar todos los valores de una capa. También se pueden modificar múltiples celdas de esta forma:\n\nelev[1, c(1, 2)] = 0\n\nResumen de objetos raster\nterra contiene funciones para extraer estadísticas descriptivas de rásters enteros. Al imprimir un objeto raster en la consola escribiendo su nombre, se obtienen los valores mínimo y máximo de un raster.\nsummary() proporciona estadísticas descriptivas comunesindex{statistics} – mínimo, máximo, cuartiles y número de NAs para rásters continuos y un número de celdas de cada clase para rásters categóricos.\nOtras operaciones de resumen, como la desviación estándar (véase más adelante) o estadísticas de resumen personalizadas, pueden calcularse con global().\n\nglobal(elev, sd)\n\n\n\n\n\n\n\nNota\n\n\n\nIf you provide the summary() and global() functions with a multi-layered raster object, they will summarize each layer separately, as can be illustrated by running: summary(c(elev, grain)).\n\n\nAdemás, la función freq() permite obtener la tabla de frecuencias de valores categóricos.\nLas estadísticas de valores raster pueden visualizarse de varias formas. Funciones específicas como boxplot(), density(), hist() y pairs() funcionan también con objetos raster, como se demuestra en el histograma creado con el comando siguiente (no mostrado):\n\nhist(elev, breaks=2)"
  },
  {
    "objectID": "operaciones_con_atributos.html#footnotes",
    "href": "operaciones_con_atributos.html#footnotes",
    "title": "Operaciones con atributos",
    "section": "Notas",
    "text": "Notas\n\n st_geometry(world_st) = NULL también funciona para eliminar la geometría de world, pero sobrescribe el objeto original.↩︎"
  },
  {
    "objectID": "geo_input_output.html",
    "href": "geo_input_output.html",
    "title": "Entrada y salida de geo-datos",
    "section": "",
    "text": "library(sf)\nlibrary(terra)\nlibrary(dplyr)\nlibrary(spData)"
  },
  {
    "objectID": "geo_input_output.html#introducción",
    "href": "geo_input_output.html#introducción",
    "title": "Entrada y salida de geo-datos",
    "section": "Introducción",
    "text": "Introducción\nEste capítulo trata sobre la lectura y escritura de datos geográficos. La entrada de datos geográficos es esencial para la geocomputación: las aplicaciones del mundo real son imposibles sin datos. La salida de datos también es vital, ya que permite a otros utilizar valiosos conjuntos de datos nuevos o mejorados resultantes de su trabajo. En conjunto, estos procesos de entrada/salida pueden denominarse E/S de datos (I/O en Inglés).\nLa E/S de datos geográficos suele realizarse con unas pocas líneas de código al principio y al final de los proyectos. A menudo se pasa por alto como un simple proceso de un solo paso. Sin embargo, los errores cometidos al principio de los proyectos (por ejemplo, utilizar un conjunto de datos obsoleto o defectuoso de alguna manera) pueden dar lugar a grandes problemas más adelante, por lo que vale la pena dedicar un tiempo considerable a identificar qué conjuntos de datos están disponibles, dónde se pueden encontrar y cómo recuperarlos. Por otra parte, existen muchos formatos de archivos geográficos, cada uno de los cuales tiene sus pros y sus contras, como así también diferentes formas de lectura y escritura eficiente."
  },
  {
    "objectID": "geo_input_output.html#recuperación-de-datos-abiertos",
    "href": "geo_input_output.html#recuperación-de-datos-abiertos",
    "title": "Entrada y salida de geo-datos",
    "section": "Recuperación de datos abiertos",
    "text": "Recuperación de datos abiertos\nCada vez hay más datos geográficos disponibles en Internet, muchos de los cuales son de acceso y uso gratuitos (siempre que se dé el crédito correspondiente a sus proveedores)1. En cierto modo, ahora hay demasiados datos, en el sentido de que a menudo hay varios sitios donde acceder al mismo conjunto de datos. Algunos conjuntos de datos son de mala calidad. En este contexto, es vital saber dónde buscar. Varios “geoportales” (servicios web que proporcionan conjuntos de datos geoespaciales, como Data.gov) son un buen punto de partida, ya que ofrecen una amplia gama de datos, pero a menudo sólo para lugares concretos (como se ilustra en la página actualizada de Wikipedia sobre el tema).\nAlgunos geoportales globales superan este problema. El portal GEOSS y el Copernicus Open Access Hub, por ejemplo, contienen muchos conjuntos de datos ráster con cobertura mundial. En el portal SEDAC, gestionado por la Administración Nacional de Aeronáutica y del Espacio (NASA), y en el geoportal INSPIRE de la Unión Europea, con cobertura mundial y regional, se puede acceder a una gran cantidad de conjuntos de datos vectoriales.\nLa mayoría de los geoportales ofrecen una interfaz gráfica que permite consultar los conjuntos de datos en función de características como la extensión espacial y temporal, siendo el EarthExplorer del Servicio Geológico de Estados Unidos un buen ejemplo. Explorar los conjuntos de datos de forma interactiva en un navegador es una forma eficaz de comprender las capas disponibles. Sin embargo, desde el punto de vista de la reproducibilidad y la eficiencia, es mejor descargar los datos mediante código. Las descargas pueden iniciarse desde la línea de comandos mediante diversas técnicas, principalmente a través de URL y API (véase Sentinel API, por ejemplo). Los archivos alojados en URL estáticas pueden descargarse con download.file(), como se ilustra en el fragmento de código siguiente que accede a PeRL: Permafrost Region Pond and Lake Database de doi.pangaea.de:\n\ndownload.file(url = \"https://hs.pangaea.de/Maps/PeRL/PeRL_permafrost_landscapes.zip\",\n              destfile = \"PeRL_permafrost_landscapes.zip\", \n              mode = \"wb\")\nunzip(\"PeRL_permafrost_landscapes.zip\")\ncanada_perma_land = read_sf(\"PeRL_permafrost_landscapes/canada_perma_land.shp\")"
  },
  {
    "objectID": "geo_input_output.html#paquetes-de-datos-geográficos",
    "href": "geo_input_output.html#paquetes-de-datos-geográficos",
    "title": "Entrada y salida de geo-datos",
    "section": "Paquetes de datos geográficos",
    "text": "Paquetes de datos geográficos\nSe han desarrollado muchos paquetes de R para acceder a datos geográficos, algunos de los cuales se presentan a continuación. Éstos proporcionan interfaces a una o más bibliotecas espaciales o geoportales y tienen como objetivo hacer que el acceso a los datos sea aún más rápido desde la línea de comandos.\n\n\n\nSelected R packages for geographic data retrieval.\n\nPackage\nDescription\n\n\n\nFedData\nDatasets maintained by the US Federal government, including elevation and land cover.\n\n\ngeodata\nDownload and import imports administrative, elevation, WorldClim data.\n\n\nosmdata\nDownload and import small OpenStreetMap datasets.\n\n\nosmextract\nDownload and import large OpenStreetMap datasets.\n\n\nrnaturalearth\nAccess to Natural Earth vector and raster data.\n\n\nrnoaa\nImports National Oceanic and Atmospheric Administration (NOAA) climate data.\n\n\n\n\n\nCabe destacar que la tabla representa sólo un pequeño número de paquetes de datos geográficos disponibles. Por ejemplo, existe un gran número de paquetes R para obtener diversos datos sociodemográficos, como tidycensus y tigris (EE.UU.), cancensus (Canadá), eurostat y giscoR (Unión Europea), o idbr (bases de datos internacionales) – lea Analyzing US Census Data para encontrar algunos ejemplos de cómo analizar dichos datos. Del mismo modo, existen varios paquetes de R que dan acceso a datos espaciales de diversas regiones y países, como bcdata (provincia de Columbia Británica), geobr (Brasil), RCzechia (Chequia) o rgugik (Polonia). Otro paquete destacable es GSODR, que proporciona un resumen global de datos meteorológicos diarios en R (consulte el README del paquete para obtener una visión general de las fuentes de datos meteorológicos).\nCada paquete de datos tiene su propia sintaxis para acceder a los datos. Esta diversidad se demuestra en los siguientes trozos de código, que muestran cómo obtener datos utilizando tres paquetes de la tabla anterior.2. Las fronteras de los países suelen ser útiles y se puede acceder a ellas con la función ne_countries() del paquete rnaturalearth de la siguiente manera:\n\nlibrary(rnaturalearth)\nusa = ne_countries(country = \"United States of America\") # United States borders\nclass(usa)\n# alternative way of accessing the data, with geodata\n# geodata::gadm(\"USA\", level = 0, path = tempdir())\n## [1] \"SpatialPolygonsDataFrame\"\n## attr(,\"package\")\n## [1] \"sp\"\n\nPor defecto rnaturalearth devuelve objetos de la clase Spatial*. El resultado se puede convertir en un objeto sf con st_as_sf() de la siguiente manera:\n\nusa_sf = st_as_sf(usa)\n\nUn segundo ejemplo descarga una serie de rásters que contienen sumas mensuales globales de precipitación con una resolución espacial de diez minutos (~18,5 km en el ecuador) utilizando el paquete geodata. El resultado es un objeto multicapa de la clase SpatRaster.\n\nlibrary(geodata)\nworldclim_prec = worldclim_global(\"prec\", res = 10, path = tempdir())\nclass(worldclim_prec)\n\nUn tercer ejemplo utiliza el paquete osmdata para buscar parques en la base de datos OpenStreetMap (OSM). Como se ilustra en el fragmento de código siguiente, las consultas comienzan con la función opq() (abreviatura de OpenStreetMap query), cuyo primer argumento es bounding box, o cadena de texto que representa un bounding box (la ciudad de Leeds en este caso). El resultado se pasa a una función para seleccionar los elementos OSM que nos interesan (parques en este caso), representados por pares clave-valor. A continuación, se pasan a la función osmdata_sf() que hace el trabajo de descargar los datos y convertirlos en una lista de objetos sf (ver vignette('osmdata') para más detalles):\n\nlibrary(osmdata)\nparks = opq(bbox = \"leeds uk\") |&gt; \n  add_osm_feature(key = \"leisure\", value = \"park\") |&gt; \n  osmdata_sf()\n\nUna limitación del paquete osmdata es que no puede descargar grandes conjuntos de datos OSM (por ejemplo, todos los datos OSM de una gran ciudad). Para superar esta limitación, se desarrolló el paquete osmextract, que se puede utilizar para descargar e importar archivos binarios .pbf que contienen versiones comprimidas de la base de datos OSM para regiones predefinidas.\nOpenStreetMap es una vasta base de datos mundial de origen colectivo que crece día a día y cuenta con un amplio ecosistema de herramientas que facilitan el acceso a los datos, desde el servicio web Overpass turbo para desarrollar y probar rápidamente consultas OSM hasta osm2pgsql para importar los datos a una base de datos PostGIS. Aunque la calidad de los conjuntos de datos derivados de OSM varía, la fuente de datos y los ecosistemas OSM más amplios tienen muchas ventajas: proporcionan conjuntos de datos disponibles a nivel mundial, gratuitos y en constante mejora gracias a un ejército de voluntarios. El uso de OSM fomenta la “ciencia ciudadana” y las contribuciones al patrimonio digital (puedes empezar a editar datos que representen una parte del mundo que conozcas bien en www.openstreetmap.org).\nA veces, los paquetes vienen con conjuntos de datos incorporados. Se puede acceder a ellos de cuatro maneras: adjuntando el paquete (si el paquete utiliza “carga lenta” como spData), con data(dataset, package = mypackage), haciendo referencia al conjunto de datos con mypackage::dataset, o con system.file(filepath, package = mypackage) para acceder a los archivos de datos sin procesar. El siguiente fragmento de código ilustra las dos últimas opciones utilizando el conjunto de datos world (ya cargado adjuntando su paquete padre con library(spData)):\n\nworld2 = spData::world\nworld3 = read_sf(system.file(\"shapes/world.gpkg\", package = \"spData\"))\n\nEl último ejemplo, system.file(\"shapes/world.gpkg\", package = \"spData\"), devuelve una ruta al archivo world.gpkg, que se almacena dentro de la carpeta \"shapes/\" del paquete spData.\nOtra forma de obtener información espacial es realizar la geocodificación: transformar la descripción de una ubicación, normalmente una dirección, en sus coordenadas. Esto suele hacerse enviando una consulta a un servicio en línea y obteniendo la ubicación como resultado. Existen muchos servicios de este tipo que difieren en el método de geocodificación utilizado, las limitaciones de uso, los costes o los requisitos de clave API. R dispone de varios paquetes para geocodificación; sin embargo, tidygeocoder parece permitir conectar con el mayor número de servicios de geocodificación con una interfaz consistente. La función principal de tidygeocoder es geocode, que toma un marco de datos con direcciones y añade coordenadas como \"lat\" y \"long\". Esta función también permite seleccionar un servicio de geocodificación con el argumento method y tiene muchos parámetros adicionales.\nEl siguiente ejemplo busca las coordenadas de la placa azul de John Snow situada en un edificio del barrio londinense del Soho.\n\nlibrary(tidygeocoder)\ngeo_df = data.frame(address = \"54 Frith St, London W1D 4SJ, UK\")\ngeo_df = geocode(geo_df, address, method = \"osm\")\ngeo_df\n\nEl data.frame resultante puede convertirse en un objeto sf con st_as_sf().\n\ngeo_sf = st_as_sf(geo_df, coords = c(\"long\", \"lat\"), crs = \"EPSG:4326\")\n\nEste paquete también permite realizar el proceso inverso denominado geocodificación inversa utilizado para obtener un conjunto de información (nombre, dirección, etc.) a partir de un par de coordenadas."
  },
  {
    "objectID": "geo_input_output.html#servicios-web-geográficos",
    "href": "geo_input_output.html#servicios-web-geográficos",
    "title": "Entrada y salida de geo-datos",
    "section": "Servicios web geográficos",
    "text": "Servicios web geográficos\nEn un esfuerzo por estandarizar las API web para acceder a los datos espaciales, el Open Geospatial Consortium (OGC) ha creado una serie de especificaciones para los servicios web (conocidos colectivamente como OWS, que es la abreviatura de OGC Web Services). Estas especificaciones incluyen el Web Feature Service (WFS), el Web Map Service (WMS), el Web Map Tile Service (WMTS), el Web Coverage Service (WCS) e incluso un Web Processing Service (WPS). Servidores de mapas como PostGIS han adoptado estos protocolos, lo que ha llevado a la estandarización de las consultas. Al igual que otras API web, las API OWS utilizan una “URL base”, un “endpoint” y “argumentos de consulta URL” seguidos de un ? para solicitar datos (véase la viñeta best-practices-api-packages en el paquete httr).\nHay muchas peticiones que se pueden hacer a un servicio OWS. Una de las más fundamentales es getCapabilities, demostrada con las funciones httr GET() y modify_url() a continuación.\nEl fragmento de código muestra cómo pueden construirse y enviarse consultas API, en este caso para descubrir las capacidades de un servicio gestionado por la Organización de las Naciones Unidas para la Agricultura y la Alimentación (FAO):\n\nlibrary(httr)\nbase_url = \"http://www.fao.org\"\nendpoint = \"/figis/geoserver/wfs\"\nq = list(request = \"GetCapabilities\")\nres = GET(url = modify_url(base_url, path = endpoint), query = q)\nres$url\n## [1] \"https://www.fao.org/figis/geoserver/wfs?request=GetCapabilities\"\n\nEl fragmento de código anterior demuestra cómo se pueden construir programáticamente las peticiones API con la función GET(), que toma una URL base y una lista de parámetros de consulta que pueden ampliarse fácilmente. El resultado de la petición se guarda en res, un objeto de la clase response definido en el paquete httr, que es una lista que contiene información de la petición, incluyendo la URL. Como puede verse ejecutando browseURL(res$url), los resultados también pueden leerse directamente en un navegador. Una forma de extraer el contenido de la petición es la siguiente:\n\ntxt = content(res, \"text\")\nxml = xml2::read_xml(txt)\n\n\nxml\n#&gt; {xml_document} ...\n#&gt; [1] &lt;ows:ServiceIdentification&gt;\\n  &lt;ows:Title&gt;GeoServer WFS...\n#&gt; [2] &lt;ows:ServiceProvider&gt;\\n  &lt;ows:ProviderName&gt;UN-FAO Fishe...\n#&gt; ...\n\nLos datos pueden descargarse de los servicios WFS con la petición GetFeature y un typeName específico (como se ilustra en el fragmento de código siguiente).\nLos nombres disponibles varían en función del servicio de características web al que se acceda. Se pueden extraer mediante programación utilizando tecnologías web o desplazándose manualmente por el contenido de la salida GetCapabilities en un navegador.\n\nqf = list(request = \"GetFeature\", typeName = \"area:FAO_AREAS\")\nfile = tempfile(fileext = \".gml\")\nGET(url = base_url, path = endpoint, query = qf, write_disk(file))\nfao_areas = read_sf(file)\n\nNótese el uso de write_disk() para asegurar que los resultados se escriben en disco en lugar de cargarse en memoria, lo que permite importarlos con sf. Este ejemplo muestra cómo obtener acceso de bajo nivel a servicios web utilizando httr, que puede ser útil para entender cómo funcionan los servicios web. Para muchas tareas cotidianas, sin embargo, puede ser más apropiada una interfaz de más alto nivel, y se han desarrollado una serie de paquetes de R, y tutoriales, precisamente con este propósito. El paquete ows4R fue desarrollado para trabajar con servicios OWS."
  },
  {
    "objectID": "geo_input_output.html#formatos-de-archivo",
    "href": "geo_input_output.html#formatos-de-archivo",
    "title": "Entrada y salida de geo-datos",
    "section": "Formatos de archivo",
    "text": "Formatos de archivo\nLos conjuntos de datos geográficos suelen almacenarse como archivos o en bases de datos espaciales. Los formatos de archivo pueden almacenar datos vectoriales o ráster, mientras que las bases de datos espaciales como PostGIS pueden almacenar ambos. Hoy en día, la variedad de formatos de archivo puede parecer desconcertante, pero se ha producido una gran consolidación y estandarización desde los inicios del software SIG en la década de 1960, cuando se creó el primer programa de amplia distribución (SYMAP) para el análisis espacial en la Universidad de Harvard.\nGDAL (que debería pronunciarse “goo-dal”, con la doble “o” en referencia a la orientación a objetos), la Biblioteca de Abstracción de Datos Geoespaciales, ha resuelto muchos problemas relacionados con la incompatibilidad entre formatos de archivos geográficos desde su lanzamiento en 2000. GDAL proporciona una interfaz unificada y de alto rendimiento para la lectura y escritura de muchos formatos de datos ráster y vectoriales.3. Muchos programas SIG abiertos y propietarios, incluidos GRASS GIS, ArcGIS y QGIS, utilizan GDAL detrás de sus interfaces gráficas de usuario para realizar el trabajo de ingesta y escupir los datos geográficos en los formatos adecuados.\nGDAL proporciona acceso a más de 200 formatos de datos vectoriales y ráster. La siguiente tabla presenta información básica sobre los formatos de archivos espaciales seleccionados y utilizados con frecuencia.\n\n\n\nSelected spatial file formats.\n\nName\nExtension\nInfo\nType\nModel\n\n\n\nESRI Shapefile\n.shp (the main file)\nPopular format consisting of at least three files. No support for: files &gt; 2GB; mixed types; names &gt; 10 chars; cols &gt; 255.\nVector\nPartially open\n\n\nGeoJSON\n.geojson\nExtends the JSON exchange format by including a subset of the simple feature representation; mostly used for storing coordinates in longitude and latitude; it is extended by the TopoJSON format\nVector\nOpen\n\n\nKML\n.kml\nXML-based format for spatial visualization, developed for use with Google Earth. Zipped KML file forms the KMZ format.\nVector\nOpen\n\n\nGPX\n.gpx\nXML schema created for exchange of GPS data.\nVector\nOpen\n\n\nFlatGeobuf\n.fgb\nSingle file format allowing for quick reading and writing of vector data. Has streaming capabilities.\nVector\nOpen\n\n\nGeoTIFF\n.tif/.tiff\nPopular raster format. A TIFF file containing additional spatial metadata.\nRaster\nOpen\n\n\nArc ASCII\n.asc\nText format where the first six lines represent the raster header, followed by the raster cell values arranged in rows and columns.\nRaster\nOpen\n\n\nSQLite/SpatiaLite\n.sqlite\nStandalone relational database, SpatiaLite is the spatial extension of SQLite.\nVector and raster\nOpen\n\n\nESRI FileGDB\n.gdb\nSpatial and nonspatial objects created by ArcGIS. Allows: multiple feature classes; topology. Limited support from GDAL.\nVector and raster\nProprietary\n\n\nGeoPackage\n.gpkg\nLightweight database container based on SQLite allowing an easy and platform-independent exchange of geodata\nVector and (very limited) raster\nOpen\n\n\n\n\n\nLa fundación del Open Geospatial Consortium (OGC) en 1994 supuso un avance importante en la normalización y la apertura de los formatos de archivo. Además de definir el modelo de datos de características simples o simple features, el OGC también coordina el desarrollo de normas abiertas, por ejemplo, las utilizadas en formatos de archivo como KML y GeoPackage. Los formatos de archivo abiertos del tipo respaldado por el OGC tienen varias ventajas sobre los formatos propietarios: los estándares se publican, garantizan la transparencia y abren la posibilidad de que los usuarios sigan desarrollando y ajustando los formatos de archivo a sus necesidades específicas.\nESRI Shapefile es el formato de intercambio de datos vectoriales más popular; sin embargo, no es un formato abierto (aunque su especificación sí lo es). Se desarrolló a principios de la década de 1990 y tiene una serie de limitaciones. En primer lugar, es un formato multiarchivo, que consta de al menos tres archivos. Sólo admite 255 columnas, los nombres de las columnas están restringidos a diez caracteres y el límite de tamaño de los archivos es de 2 GB. Además, ESRI Shapefile no admite todos los tipos de geometría posibles, por ejemplo, no es capaz de distinguir entre un polígono y un multipolígono.4 A pesar de estas limitaciones, hacía tiempo que se echaba en falta una alternativa viable. Mientras tanto, surgió GeoPackage, y parece ser un candidato más que adecuado para sustituir a ESRI Shapefile. Geopackage es un formato de intercambio de información geoespacial y una norma OGC. La norma GeoPackage describe las reglas para almacenar información geoespacial en un pequeño contenedor SQLite. Por lo tanto, GeoPackage es un contenedor de base de datos espacial ligero, que permite almacenar datos vectoriales y ráster, pero también datos no espaciales y extensiones. Aparte de GeoPackage, hay otros formatos de intercambio de datos geoespaciales que merece la pena consultar.\nEl formato GeoTIFF parece ser el formato de datos ráster más destacado. Permite incrustar información espacial, como CRS, en un archivo TIFF. Al igual que ESRI Shapefile, este formato se desarrolló por primera vez en los años 90, pero como formato abierto. Además, GeoTIFF sigue ampliándose y mejorándose. Una de las recientes incorporaciones más significativas al formato GeoTIFF es su variante denominada COG (Cloud Optimized GeoTIFF). Los objetos ráster guardados como COG pueden alojarse en servidores HTTP, de modo que otras personas puedan leer sólo partes del archivo sin descargarlo entero.\nAdemás, se están desarrollando nuevos formatos de datos espaciales (por ejemplo, GeoParquet y Zarr) y se están mejorando los existentes. Si necesita más información sobre otros formatos, le recomendamos que lea la documentación de GDAL sobre los controladores vector y raster. Además, algunos formatos de datos espaciales pueden almacenar otros modelos (tipos) de datos que no sean vectoriales o ráster. Entre ellos se incluyen los formatos LAS y LAZ para almacenar nubes de puntos lidar, y NetCDF y HDF para almacenar matrices multidimensionales.\nLos datos espaciales también suelen almacenarse en formatos de texto tabulares (no espaciales), como archivos CSV u hojas de cálculo Excel. Por ejemplo, esto puede ser conveniente para compartir muestras espaciales con personas que no utilizan herramientas SIG o intercambiar datos con otro software que no acepte formatos de datos espaciales. Sin embargo, este enfoque tiene varios posibles problemas: es bastante complicado para almacenar geometrías más complejas que los POINT y no almacena directamente información sobre los CRS."
  },
  {
    "objectID": "geo_input_output.html#entrada-de-datos-i",
    "href": "geo_input_output.html#entrada-de-datos-i",
    "title": "Entrada y salida de geo-datos",
    "section": "Entrada de datos (I)",
    "text": "Entrada de datos (I)\nLa ejecución de comandos como sf::read_sf() (la función principal que utilizamos para cargar datos vectoriales) o terra::rast() (la función principal utilizada para cargar datos raster) desencadena silenciosamente una cadena de eventos que lee datos de archivos. Además, existen muchos paquetes de R que contienen una amplia gama de datos geográficos o que proporcionan un acceso sencillo a distintas fuentes de datos. Todos ellos cargan los datos en R o, más exactamente, asignan objetos a su espacio de trabajo, almacenados en RAM accesible desde el .GlobalEnv de la sesión de R.\nVector data\nLos datos vectoriales espaciales vienen en una amplia variedad de formatos de archivo. Las representaciones más populares, como los archivos .geojson y .gpkg se pueden importar directamente en R con la función sf read_sf() (o la equivalente st_read()), que utiliza los controladores vectoriales de GDAL entre bastidores. st_drivers() devuelve un marco de datos que contiene name y long_name en las dos primeras columnas, y las características de cada controlador disponible para GDAL (y por lo tanto sf), incluyendo la capacidad de escribir datos y almacenar datos raster en las columnas siguientes, como se ilustra para los formatos de archivo clave en la Tabla (tab:drivers).\nLos siguientes comandos muestran los tres primeros controladores de los que informa la instalación de GDAL del ordenador (los resultados pueden variar en función de la versión de GDAL instalada) y un resumen de sus características. Nótese que la mayoría de los drivers pueden escribir datos (51 de 87) mientras que sólo 16 formatos pueden representar eficientemente datos raster además de datos vectoriales (ver ?st_drivers() para más detalles):\n\nsf_drivers = st_drivers()\nhead(sf_drivers, n = 3)\nsummary(sf_drivers[-c(1:2)])\n\n\n\n\nPopular drivers/formats for reading/writing vector data.\n\nname\nlong_name\nwrite\ncopy\nis_raster\nis_vector\nvsi\n\n\n\nESRI Shapefile\nESRI Shapefile\nTRUE\nFALSE\nFALSE\nTRUE\nTRUE\n\n\nGPX\nGPX\nTRUE\nFALSE\nFALSE\nTRUE\nTRUE\n\n\nKML\nKeyhole Markup Language (KML)\nTRUE\nFALSE\nFALSE\nTRUE\nTRUE\n\n\nGeoJSON\nGeoJSON\nTRUE\nFALSE\nFALSE\nTRUE\nTRUE\n\n\nGPKG\nGeoPackage\nTRUE\nTRUE\nTRUE\nTRUE\nTRUE\n\n\nFlatGeobuf\nFlatGeobuf\nTRUE\nFALSE\nFALSE\nTRUE\nTRUE\n\n\n\n\n\nEl primer argumento de read_sf() es dsn, que debe ser una cadena de texto o un objeto que contenga una única cadena de texto. El contenido de una cadena de texto puede variar entre diferentes controladores. En la mayoría de los casos, como con el ESRI Shapefile (.shp) o el formato GeoPackageindex{GeoPackage} (.gpkg), el dsn sería un nombre de archivo. read_sf() adivina el controlador basado en la extensión del archivo, como se ilustra para un archivo .gpkg a continuación:\n\nf = system.file(\"shapes/world.gpkg\", package = \"spData\")\nworld = read_sf(f, quiet = TRUE)\n\nPara algunos controladores, dsn podría proporcionarse como un nombre de carpeta, credenciales de acceso a una base de datos, o una representación de cadena GeoJSON (ver los ejemplos de la página de ayuda read_sf() para más detalles).\nAlgunos formatos de controladores vectoriales pueden almacenar múltiples capas de datos. Por defecto, read_sf() lee automáticamente la primera capa del archivo especificado en dsn; sin embargo, utilizando el argumento layer se puede especificar cualquier otra capa.\nLa función read_sf() también permite leer sólo partes del fichero en la RAM con dos mecanismos posibles. El primero está relacionado con el argumento query, que permite especificar qué parte de los datos leer con el texto de consulta OGR SQL. En el ejemplo siguiente se extraen los datos de Tanzania únicamente. Se hace especificando que queremos obtener todas las columnas (SELECT *) de la capa \"world\" para las que el name_long es igual a \"Tanzania\":\n\ntanzania = read_sf(f, query = 'SELECT * FROM world WHERE name_long = \"Tanzania\"')\n\nSi no conoce los nombres de las columnas disponibles, un buen método consiste en leer simplemente una fila de los datos con 'SELECT * FROM world WHERE FID = 1'. El FID representa un ID de característica – la mayoría de las veces, es un número de fila; sin embargo, sus valores dependen del formato de fichero utilizado. Por ejemplo, FID empieza por 0 en ESRI Shapefile, por 1 en algunos otros formatos de archivo, o incluso puede ser arbitrario.\nEl segundo mecanismo utiliza el argumento wkt_filter. Este argumento espera un texto conocido que representa el área de estudio de la que queremos extraer los datos. Intentémoslo con un pequeño ejemplo: queremos leer los polígonos de nuestro archivo que se cruzan con el buffer de 50.000 metros de las fronteras de Tanzania. Para ello, tenemos que preparar nuestro “filtro” (a) creando el buffer, (b) convirtiendo el objeto buffer sf en un objeto geométrico sfc con st_geometry(), y (c) traduciendo las geometrías a su conocida representación de texto con st_as_text():\n\ntanzania_buf = st_buffer(tanzania, 50000)\ntanzania_buf_geom = st_geometry(tanzania_buf)\ntanzania_buf_wkt = st_as_text(tanzania_buf_geom)\n\nAhora, podemos aplicar este “filtro” usando el argumento wkt_filter.\n\ntanzania_neigh = read_sf(f, wkt_filter = tanzania_buf_wkt)\n\nNuestro resultado contiene Tanzania y todos los países que se encuentran dentro de su buffer de 50 km.\n\n\n\n\nReading a subset of the vector data using a query (A) and a wkt filter (B).\n\n\n\nNaturalmente, algunas opciones son específicas de determinados controladores.5 Por ejemplo, pensemos en coordenadas almacenadas en un formato de hoja de cálculo (.csv). Para leer estos archivos como objetos espaciales, naturalmente tenemos que especificar los nombres de las columnas (X y Y en nuestro ejemplo de abajo) que representan las coordenadas. Podemos hacerlo con la ayuda del parámetro options. Para conocer las posibles opciones, consulte la sección Opciones abiertas de la descripción del controlador GDAL correspondiente. Para el formato de valores separados por comas (csv), visite http://www.gdal.org/drv_csv.html.\n\ncycle_hire_txt = system.file(\"misc/cycle_hire_xy.csv\", package = \"spData\")\ncycle_hire_xy = read_sf(cycle_hire_txt,\n  options = c(\"X_POSSIBLE_NAMES=X\", \"Y_POSSIBLE_NAMES=Y\"))\n\nEn lugar de columnas que describan las coordenadas “XY”, una sola columna puede contener también la información geométrica. Los formatos de texto conocido (WKT), binario conocido (WKB) y GeoJSON son ejemplos de ello. Por ejemplo, el archivo world_wkt.csv tiene una columna llamada WKT que representa polígonos de los países del mundo. Una vez más, utilizaremos el parámetro options para indicarlo.\n\nworld_txt = system.file(\"misc/world_wkt.csv\", package = \"spData\")\nworld_wkt = read_sf(world_txt, options = \"GEOM_POSSIBLE_NAMES=WKT\")\n# the same as\nworld_wkt2 = st_read(world_txt, options = \"GEOM_POSSIBLE_NAMES=WKT\", \n                    quiet = TRUE, stringsAsFactors = FALSE, as_tibble = TRUE)\n\n\n\n\n\n\n\nNota\n\n\n\nNo todos los formatos de ficheros vectoriales soportados almacenan información sobre su sistema de referencia de coordenadas. En estas situaciones, es posible añadir la información que falta utilizando la función st_set_crs().\n\n\nComo ejemplo final, mostraremos cómo read_sf() también lee archivos KML. Un archivo KML almacena información geográfica en formato XML, un formato de datos para la creación de páginas web y la transferencia de datos de forma independiente de la aplicación. Aquí, accedemos a un archivo KML desde la web. Este archivo contiene más de una capa. st_layers() lista todas las capas disponibles. Elegimos la primera capa Placemarks y lo decimos con la ayuda del parámetro layer en read_sf().\n\nu = \"https://developers.google.com/kml/documentation/KML_Samples.kml\"\ndownload.file(u, \"KML_Samples.kml\")\nst_layers(\"KML_Samples.kml\")\nkml = read_sf(\"KML_Samples.kml\", layer = \"Placemarks\")\n## Driver: LIBKML \n## Available layers:\n##               layer_name geometry_type features fields crs_name\n## 1             Placemarks                      3     11   WGS 84\n## 2      Styles and Markup                      1     11   WGS 84\n## 3       Highlighted Icon                      1     11   WGS 84\n## 4        Ground Overlays                      1     11   WGS 84\n## 5        Screen Overlays                      0     11   WGS 84\n## 6                  Paths                      6     11   WGS 84\n## 7               Polygons                      0     11   WGS 84\n## 8          Google Campus                      4     11   WGS 84\n## 9       Extruded Polygon                      1     11   WGS 84\n## 10 Absolute and Relative                      4     11   WGS 84\n\nTodos los ejemplos presentados hasta ahora en esta sección han utilizado el paquete sf para la importación de datos geográficos. Es rápido y flexible, pero puede merecer la pena buscar otros paquetes para formatos de archivo específicos. Un ejemplo es el paquete geojsonsf. Un benchmark sugiere que es unas 10 veces más rápido que el paquete sf para leer .geojson.\nDatos raster\nAl igual que los datos vectoriales, los datos raster vienen en muchos formatos de archivo, algunos de los cuales soportan archivos multicapa. El comando rast() de terra lee una sola capa cuando se proporciona un archivo con una sola capa.\n\nraster_filepath = system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nsingle_layer = rast(raster_filepath)\n\nTambién funciona en caso de que quieras leer un fichero multicapa.\n\nmultilayer_filepath = system.file(\"raster/landsat.tif\", package = \"spDataLarge\")\nmultilayer_rast = rast(multilayer_filepath)\n\nTodos los ejemplos anteriores leen información espacial de archivos almacenados en su disco duro. Sin embargo, GDAL también permite leer datos directamente de recursos en línea, como recursos web HTTP/HTTPS/FTP. Lo único que tenemos que hacer es añadir un prefijo /vsicurl/ antes de la ruta al fichero. Vamos a probarlo conectándonos a la probabilidad de nieve mensual global a 500 m de resolución para el periodo 2000-2012. La probabilidad de nieve para diciembre se almacena como archivo COG (Cloud Optimized GeoTIFF) en . Para leer un archivo en línea, basta con proporcionar su URL junto con el prefijo /vsicurl/.\n\nmyurl = \"/vsicurl/https://zenodo.org/record/5774954/files/clm_snow.prob_esacci.dec_p.90_500m_s0..0cm_2000..2012_v2.0.tif\"\nsnow = rast(myurl)\nsnow\n## class       : SpatRaster \n## dimensions  : 35849, 86400, 1  (nrow, ncol, nlyr)\n## resolution  : 0.004166667, 0.004166667  (x, y)\n## extent      : -180, 180, -62.00083, 87.37  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source      : clm_snow.prob_esacci.dec_p.90_500m_s0..0cm_2000..2012_v2.0.tif \n## name        : clm_snow.prob_esacci.dec_p.90_500m_s0..0cm_2000..2012_v2.0\n\nDebido a que los datos de entrada son COG, en realidad no estamos leyendo este fichero en nuestra RAM, sino creando una conexión con él sin obtener ningún valor. Sus valores serán leídos si aplicamos cualquier operación basada en valores (por ejemplo, crop() o extract()). Esto nos permite también leer sólo una pequeña porción de los datos sin descargar todo el fichero. Por ejemplo, podemos obtener la probabilidad de nieve para diciembre en Reikiavik (70%) especificando sus coordenadas y aplicando la función extract():\n\nrey = data.frame(lon = -21.94, lat = 64.15)\nsnow_rey = extract(snow, rey)\nsnow_rey\n\n\n\n\n\n\nID\n\n\nclm_snow.prob_esacci.dec_p.90_500m_s0..0cm_2000..2012_v2.0\n\n\n\n\n1\n\n\n70\n\n\n\n\n\n\nDe esta forma, sólo descargamos un único valor en lugar de todo el archivo GeoTIFF de gran tamaño.\nEl ejemplo anterior sólo muestra un caso sencillo (pero útil), pero hay más por explorar. El prefijo /vsicurl/ también funciona no sólo para los formatos de archivo raster, sino también para los vectoriales. Permite leer vectores directamente desde el almacenamiento en línea con read_sf() simplemente añadiendo el prefijo antes de la URL del archivo vectorial.\nEs importante destacar que /vsicurl/ no es el único prefijo proporcionado por GDAL; existen muchos más, como /vsizip/ para leer archivos espaciales de archivos ZIP sin descomprimirlos previamente o /vsis3/ para leer sobre la marcha archivos disponibles en cubos S3 de AWS. Puede obtener más información en https://gdal.org/user/virtual_file_systems.html."
  },
  {
    "objectID": "geo_input_output.html#salida-de-datos-o",
    "href": "geo_input_output.html#salida-de-datos-o",
    "title": "Entrada y salida de geo-datos",
    "section": "Salida de datos (O)",
    "text": "Salida de datos (O)\nLa escritura de datos geográficos permite convertir de un formato a otro y guardar objetos recién creados. Dependiendo del tipo de datos (vector o raster), clase de objeto (por ejemplo, sf o SpatRaster), y tipo y cantidad de información almacenada (por ejemplo, tamaño del objeto, rango de valores), es importante saber cómo almacenar archivos espaciales de la manera más eficiente. En las dos secciones siguientes se muestra cómo hacerlo.\nVector data\nLa contrapartida de read_sf() es write_sf(). Permite escribir objetos sf en una amplia gama de formatos de archivos vectoriales geográficos, incluidos los más comunes como .geojson, .shp y .gpkg. Basándose en el nombre del archivo, write_sf() decide automáticamente qué controlador utilizar. La velocidad del proceso de escritura depende también del controlador.\n\nwrite_sf(obj = world, dsn = \"world.gpkg\")\n\nNota: si intentas escribir de nuevo en la misma fuente de datos, la función sobrescribirá el fichero:\n\nwrite_sf(obj = world, dsn = \"world.gpkg\")\n\nEn lugar de sobrescribir el archivo, podríamos añadir una nueva capa al archivo con append = TRUE, que es soportado por varios formatos espaciales, incluyendo GeoPackage.\n\nwrite_sf(obj = world, dsn = \"world_many_layers.gpkg\", append = TRUE)\n\nAlternativamente, puede usar st_write() ya que es equivalente a write_sf(). Sin embargo, tiene diferentes valores por defecto – no sobrescribe archivos (devuelve un error cuando intenta hacerlo) y muestra un breve resumen del formato del archivo escrito y el objeto.\n\nst_write(obj = world, dsn = \"world2.gpkg\")\n## Writing layer `world2' to data source `world2.gpkg' using driver `GPKG'\n## Writing 177 features with 10 fields and geometry type Multi Polygon.\n\nEl argumento layer_options también se puede utilizar para muchos propósitos diferentes. Uno de ellos es escribir datos espaciales en un fichero de texto. Esto puede hacerse especificando GEOMETRY dentro de layer_options. Puede ser AS_XY para conjuntos de datos de puntos simples (crea dos nuevas columnas para las coordenadas) o AS_WKT para datos espaciales más complejos (se crea una nueva columna que contiene la conocida representación textual de los objetos espaciales).\n\nwrite_sf(cycle_hire_xy, \"cycle_hire_xy.csv\", layer_options = \"GEOMETRY=AS_XY\")\nwrite_sf(world_wkt, \"world_wkt.csv\", layer_options = \"GEOMETRY=AS_WKT\")\n\nDatos Raster\nLa función writeRaster() guarda objetos SpatRaster en archivos de disco. La función espera información sobre el tipo de datos de salida y el formato de archivo, pero también acepta opciones de GDAL específicas para el formato de archivo seleccionado (véase ?writeRaster para más detalles).\nEl paquete terra ofrece siete tipos de datos a la hora de guardar una trama: INT1U, INT2S, INT2U, INT4S, INT4U, FLT4S, y FLT8S.6 El tipo de datos determina la representación en bits del objeto ráster escrito en el disco. El tipo de datos a utilizar depende del rango de valores del objeto raster. Cuantos más valores pueda representar un tipo de datos, más grande será el archivo en disco. Los enteros sin signo (INT1U, INT2U, INT4U) son adecuados para datos categóricos, mientras que los números flotantes (FLT4S y FLT8S) suelen representar datos continuos. writeRaster() utiliza FLT4S por defecto. Aunque esto funciona en la mayoría de los casos, el tamaño del fichero de salida será innecesariamente grande si guarda datos binarios o categóricos. Por lo tanto, recomendamos utilizar el tipo de datos que necesite menos espacio de almacenamiento, pero que sea capaz de representar todos los valores (compruebe el rango de valores con la función summary()).\n\n\n\nData types supported by the terra package.\n\nData type\nMinimum value\nMaximum value\n\n\n\nINT1U\n0\n255\n\n\nINT2S\n-32,767\n32,767\n\n\nINT2U\n0\n65,534\n\n\nINT4S\n-2,147,483,647\n2,147,483,647\n\n\nINT4U\n0\n4,294,967,296\n\n\nFLT4S\n-3.4e+38\n3.4e+38\n\n\nFLT8S\n-1.7e+308\n1.7e+308\n\n\n\n\n\nPor defecto, el formato del archivo de salida se deriva del nombre del archivo. Al nombrar un archivo *.tif se creará un archivo GeoTIFF, como se muestra a continuación:\n\nwriteRaster(single_layer, filename = \"my_raster.tif\", datatype = \"INT2U\")\n\nAlgunos formatos de archivo ráster tienen opciones adicionales, que pueden establecerse proporcionando parámetros GDAL al argumento options de writeRaster(). Los archivos GeoTIFF se escriben en terra, por defecto, con la compresión LZW gdal = c(\"COMPRESS=LZW\"). Para cambiar o desactivar la compresión, necesitamos modificar este argumento.\n\nwriteRaster(x = single_layer, filename = \"my_raster.tif\",\n            gdal = c(\"COMPRESS=NONE\"), overwrite = TRUE)\n\nAdemás, podemos guardar nuestro objeto raster como COG (Cloud Optimized GeoTIFF) con las opciones filetype = \"COG\".\n\nwriteRaster(x = single_layer, filename = \"my_raster.tif\",\n            filetype = \"COG\", overwrite = TRUE)"
  },
  {
    "objectID": "geo_input_output.html#resultados-visuales",
    "href": "geo_input_output.html#resultados-visuales",
    "title": "Entrada y salida de geo-datos",
    "section": "Resultados visuales",
    "text": "Resultados visuales\nR soporta muchos formatos diferentes de gráficos estáticos e interactivos. El método más general para guardar un gráfico estático es abrir un dispositivo gráfico, crear un gráfico y cerrarlo, por ejemplo:\n\npng(filename = \"lifeExp.png\", width = 500, height = 350)\nplot( world[\"lifeExp\"])\ndev.off()\n\nOtros dispositivos gráficos disponibles son pdf(), bmp(), jpeg() y tiff(). Puede especificar varias propiedades del gráfico de salida, como la anchura, la altura y la resolución.\nAdemás, varios paquetes gráficos proporcionan sus propias funciones para guardar una salida gráfica. Por ejemplo, el paquete tmap tiene la función tmap_save(). Puede guardar un objeto tmap en diferentes formatos gráficos o en un archivo HTML especificando el nombre del objeto y una ruta a un nuevo archivo.\n\nlibrary(tmap)\ntmap_obj = tm_shape(world) + tm_polygons(col = \"lifeExp\")\ntmap_save(tmap_obj, filename = \"lifeExp_tmap.png\")\n\nPor otra parte, puede guardar los mapas interactivos creados en el paquete mapview como un archivo HTML o una imagen utilizando la función mapshot():\n\nlibrary(mapview)\nmapview_obj = mapview(world, zcol = \"lifeExp\", legend = TRUE)\nmapshot(mapview_obj, file = \"my_interactive_map.html\")"
  },
  {
    "objectID": "geo_input_output.html#footnotes",
    "href": "geo_input_output.html#footnotes",
    "title": "Entrada y salida de geo-datos",
    "section": "Notas",
    "text": "Notas\n\nPor ejemplo, visite https://freegisdata.rtwilson.com/ para consultar una lista de sitios web con conjuntos de datos geográficos de libre acceso↩︎\nEn https://rspatialdata.github.io/ se pueden encontrar más ejemplos de descarga de datos utilizando paquetes R dedicados↩︎\nGDAL también contiene un conjunto de funciones de utilidad que permiten la creación de mosaicos ráster, el remuestreo, el recorte y la reproyección, etc.↩︎\nPara obtener más información sobre las limitaciones de ESRI Shapefile y posibles formatos de archivo alternativos, visite http://switchfromshapefile.org/.↩︎\n Puede encontrar una lista de los formatos vectoriales y opciones compatibles en http://gdal.org/ogr_formats.html.↩︎\n No se recomienda usar INT4U ya que R no soporta enteros sin signo de 32 bits.↩︎"
  },
  {
    "objectID": "datos_espaciales_en_R.html",
    "href": "datos_espaciales_en_R.html",
    "title": "Datos espaciales en R",
    "section": "",
    "text": "Para esta fugaz intro a los datos espaciales en R, vamos a usar el libro “Geocomputation with R” que puede consultarse online aquí: https://r.geocompx.org/. Vamos a ir siguiendo algunos ejemplos del libro y quien desee conocer más detalles, puede consultarlos directamente allí o en los materiales que los autores mencionan.\nEn esta clase vamos a ver los conceptos básicos sobre los tipos fundamentales de datos geográficos: vector y raster. Veremos cómo están implementados en R, y ejemplificaremos algunas de las tareas más comunes que podemos realizar con cada uno de ellos.\nEl modelo de datos vectoriales representa el mundo mediante puntos, líneas y polígonos. Éstos tienen bordes discretos y bien definidos, lo que significa que los conjuntos de datos vectoriales suelen ser muy precisos (aunque no necesariamente exactos). El modelo de datos ráster divide la superficie en celdas de tamaño constante, generalmente. Los datos ráster agregan características a una resolución determinada, lo que significa que son coherentes en el espacio y escalables.\n\n\n\n\n\n\nNota\n\n\n\n¿Cuál utilizar? La respuesta depende probablemente de su ámbito de aplicación:\n\nLos datos vectoriales tienden a dominar las ciencias sociales porque los asentamientos humanos tienden a tener fronteras discretas\nLos datos rasterizados predominan en muchas ciencias medioambientales por su dependencia de los datos de teledetección.\n\n\n\n\nEl modelo de datos vectoriales geográficos se basa en puntos situados dentro de un sistema de referencia de coordenadas (CRS). Los puntos pueden representar características autónomas (por ejemplo, la ubicación de una parada de autobús) o pueden unirse para formar geometrías más complejas, como líneas y polígonos.\n\nEl paquete sf nos permite trabajar con datos vectoriales en R. Simple Features es un estándar abierto desarrollado y aprobado por el Open Geospatial Consortium (OGC). Simple Features es un modelo de datos jerárquico que representa una amplia gama de tipos de geometría. sf puede representar todos los tipos de geometría vectorial habituales (sf no admite clases de datos ráster): puntos, líneas, polígonos y sus respectivas versiones “multi” (que agrupan características del mismo tipo en una única característica). sf también admite colecciones de geometría, que pueden contener múltiples tipos de geometría en un único objeto. Simple features es un modelo de datos ampliamente soportado que subyace en las estructuras de datos de muchas aplicaciones SIG, incluyendo QGIS y PostGIS.\nLa funcionalidad de sf está bien documentada en su sitio web https://r-spatial.github.io/sf/, que contiene 7 viñetas. Estas se pueden ver de la siguiente manera:\n\n#vignette(package = \"sf\") # see which vignettes are available\n#vignette(\"sf1\")          # an introduction to the package\n\n\nLos objetos feature simples en R se almacenan en un data.frame (tabla de datos), con los datos geográficos ocupando una columna especial, normalmente llamada ‘geom’ o ‘geometry’. Utilizaremos el conjunto de datos world proporcionado por spData para mostrar qué son los objetos sf y cómo funcionan.\n\nclass(world)\nnames(world)\nhead(world)\n## [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n##  [1] \"iso_a2\"    \"name_long\" \"continent\" \"region_un\" \"subregion\" \"type\"     \n##  [7] \"area_km2\"  \"pop\"       \"lifeExp\"   \"gdpPercap\" \"geom\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\niso_a2\nname_long\ncontinent\nregion_un\nsubregion\ntype\narea_km2\npop\nlifeExp\ngdpPercap\ngeom\n\n\n\nFJ\nFiji\nOceania\nOceania\nMelanesia\nSovereign country\n19289.97\n885806\n69.96000\n8222.254\nMULTIPOLYGON (((-180 -16.55…\n\n\nTZ\nTanzania\nAfrica\nAfrica\nEastern Africa\nSovereign country\n932745.79\n52234869\n64.16300\n2402.099\nMULTIPOLYGON (((33.90371 -0…\n\n\nEH\nWestern Sahara\nAfrica\nAfrica\nNorthern Africa\nIndeterminate\n96270.60\nNA\nNA\nNA\nMULTIPOLYGON (((-8.66559 27…\n\n\nCA\nCanada\nNorth America\nAmericas\nNorthern America\nSovereign country\n10036042.98\n35535348\n81.95305\n43079.143\nMULTIPOLYGON (((-132.71 54….\n\n\nUS\nUnited States\nNorth America\nAmericas\nNorthern America\nCountry\n9510743.74\n318622525\n78.84146\n51921.985\nMULTIPOLYGON (((-171.7317 6…\n\n\nKZ\nKazakhstan\nAsia\nAsia\nCentral Asia\nSovereign country\n2729810.51\n17288285\n71.62000\n23587.338\nMULTIPOLYGON (((87.35997 49…\n\n\n\n\n\n\nEl contenido de esta columna geom es la que confiere a los objetos sf sus poderes espaciales: world$geom es una “columna lista” de la clase sfc que contiene todas las coordenadas de los polígonos de los países. Los objetos sf pueden visualizarse rápidamente con la función plot()\n\nplot(world)\n\n\n\n\nPodemos obtener info de los atributos (columnas) de los objetos sf, como se hace con cualquier data.frame:\n\nsummary(world[\"lifeExp\"])\n##     lifeExp                 geom    \n##  Min.   :50.62   MULTIPOLYGON :177  \n##  1st Qu.:64.96   epsg:4326    :  0  \n##  Median :72.87   +proj=long...:  0  \n##  Mean   :70.85                      \n##  3rd Qu.:76.78                      \n##  Max.   :83.59                      \n##  NA's   :10\n\nLos objetos sf son fáciles de subdividir. Por ejemplo, podemos recortar sólo las dos primeras filas y las tres primeras columnas del objeto world.\n\nworld_mini = world[1:2, 1:3]\nplot(world_mini)\n\n\n\n\nTambién podemos subdividir por columnas únicamente, ya sea con su índice o el nombre\n\nplot(world[3:6])\n\n\n\nplot(world[\"pop\"])\n\n\n\n\nPodemos hacer selecciones\n\nworld_asia = world[world$continent == \"Asia\", ]\nasia = st_union(world_asia)\n\ny añadir capas a las imágenes existentes estableciendo add = TRUE\n\nplot(world[\"pop\"], reset = FALSE)\nplot(asia, col = \"red\", add = TRUE)\n\n\n\n\nHay varias formas de modificar los mapas con el método plot() de sf. Por ejemplo, se pueden superponer círculos, cuyos diámetros (fijados con cex =) representan poblaciones de países, en un mapa del mundo.\n\nplot(world[\"continent\"], reset = FALSE)\ncex = sqrt(world$pop) / 10000\nworld_cents = st_centroid(world, of_largest = TRUE)\nplot(st_geometry(world_cents), add = TRUE, cex = cex)\n\n\n\n\n\nLas geometrías son los componentes básicos de los objetos sf y pueden adoptar uno de los 18 tipos de geometría que admite el paquete sf. Los siete tipos más utilizados son: PUNTO, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON y GEOMETRYCOLLECTION.\nPor lo general, el usuario se ahorra la tediosa tarea de crear geometrías por su cuenta, ya que puede simplemente importar un archivo espacial ya existente. Sin embargo, existe un conjunto de funciones para crear objetos geométricos de características simples (sfg) desde cero si es necesario. Los nombres de estas funciones son sencillos, todas comienzan con el prefijo st_ y terminan con el nombre del tipo de geometría:\n\nUn punto: st_point()\n\nUna cadena de líneas: st_linestring()\n\nUn polígono: st_polygon()\n\nUn multipunto: st_multipoint()\n\nUna multilínea: st_multilínea()\n\nUn multipolígono: st_multipolygon()\n\nUna colección de geometrías: st_geometrycollection()\n\n\nLos objetos sfg pueden crearse a partir de tres tipos de datos R básicos:\n\nUn vector numérico: un único punto\nUna matriz: un conjunto de puntos, donde cada fila representa un punto, un multipunto o una cadena de líneas\nUna lista: una colección de objetos como matrices, multilíneas o colecciones de geometría.\n\nEl modelo de datos espaciales ráster representa el mundo con la cuadrícula continua de celdas (a menudo también llamadas píxeles). Este modelo de datos se refiere a menudo a las denominadas cuadrículas regulares, en las que cada celda tiene el mismo tamaño constante.\nEl modelo de datos ráster suele constar de una cabecera ráster y una matriz (con filas y columnas) que representa celdas equidistantes (a menudo también denominadas píxeles). La cabecera ráster define el sistema de referencia de coordenadas, la extensión y el origen. El origen (o punto de partida) suele ser la coordenada de la esquina inferior izquierda de la matriz (el paquete terra, sin embargo, utiliza por defecto la esquina superior izquierda). La cabecera define la extensión mediante el número de columnas, el número de filas y la resolución del tamaño de las celdas. De este modo, partiendo del origen, podemos acceder fácilmente a cada celda y modificarla, ya sea utilizando el ID de una celda o especificando explícitamente las filas y columnas. Esta representación matricial evita almacenar explícitamente las coordenadas de los cuatro puntos de esquina (de hecho, sólo almacena una coordenada, el origen) de cada esquina de celda, como ocurriría en el caso de los polígonos vectoriales rectangulares. Sin embargo, a diferencia de los datos vectoriales, la celda de una capa raster sólo puede contener un único valor. El valor puede ser numérico o categórico.\n\nLos mapas raster suelen representar fenómenos continuos como la elevación, la temperatura, la densidad de población o datos espectrales. En el modelo de datos raster también pueden representarse características discretas, como clases de suelo o de cubierta terrestre.\n\n\nEn las dos últimas décadas, se han desarrollado varios paquetes para leer y procesar conjuntos de datos raster. El principal de ellos fue raster, que supuso un cambio radical en las capacidades raster de R cuando se lanzó en 2010 y se convirtió en el principal paquete en este ámbito hasta el desarrollo de terra y stars. Estos últimos, desarrollados más recientemente, ofrecen funciones potentes y eficaces para trabajar con conjuntos de datos ráster, y existe un solapamiento sustancial entre sus posibles casos de uso. Aquí nos vamos a centrar en el paquete terra.\n\nEl paquete terra soporta objetos raster en R. Al igual que su predecesor raster (creado por el mismo desarrollador, Robert Hijmans), proporciona un amplio conjunto de funciones para crear, leer, exportar, manipular y procesar conjuntos de datos raster. La funcionalidad de terra es en gran medida la misma que la del paquete raster, pero hay algunas diferencias: las funciones de terra suelen ser más eficientes computacionalmente. Puede traducir sin problemas entre los dos tipos de objetos para garantizar la compatibilidad con scripts y paquetes más antiguos, por ejemplo, con las funciones raster(), stack() y brick() en el paquete raster.\nAdemás de las funciones para la manipulación de datos ráster, terra proporciona muchas funciones de bajo nivel que pueden constituir una base para el desarrollo de nuevas herramientas para trabajar con conjuntos de datos ráster. terra también le permite trabajar con grandes conjuntos de datos ráster que son demasiado grandes para caber en la memoria principal. En este caso, terra ofrece la posibilidad de dividir el raster en trozos más pequeños, y procesarlos iterativamente en lugar de cargar todo el archivo raster en la RAM.\n\nraster_filepath = system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nmy_rast = rast(raster_filepath)\nclass(my_rast)\n## [1] \"SpatRaster\"\n## attr(,\"package\")\n## [1] \"terra\"\n\n\nmy_rast\n## class       : SpatRaster \n## dimensions  : 457, 465, 1  (nrow, ncol, nlyr)\n## resolution  : 0.0008333333, 0.0008333333  (x, y)\n## extent      : -113.2396, -112.8521, 37.13208, 37.51292  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source      : srtm.tif \n## name        : srtm \n## min value   : 1024 \n## max value   : 2892\n\n\nplot(my_rast)\n\n\n\n\nClases de datos raster\nEl paquete terra soporta numerosos controladores con la ayuda de la biblioteca GDAL. Por lo general, los rásters de los archivos no se leen completamente en la RAM, a excepción de su cabecera y un puntero al archivo.\n\nsingle_raster_file = system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nsingle_rast = rast(raster_filepath)\nsingle_rast\n## class       : SpatRaster \n## dimensions  : 457, 465, 1  (nrow, ncol, nlyr)\n## resolution  : 0.0008333333, 0.0008333333  (x, y)\n## extent      : -113.2396, -112.8521, 37.13208, 37.51292  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source      : srtm.tif \n## name        : srtm \n## min value   : 1024 \n## max value   : 2892\n\nLos rásters también pueden crearse desde cero utilizando la misma función rast().\n\nnew_raster = rast(nrows = 6, ncols = 6, \n                  xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n                  vals = 1:36)\nplot(new_raster)\n\n\n\n\nLa clase SpatRaster también puede manejar múltiples capas, por ejemplo, las bandas de un satélite multiespectral o una serie temporal de rásters.\n\nmulti_raster_file = system.file(\"raster/landsat.tif\", package = \"spDataLarge\")\nmulti_rast = rast(multi_raster_file)\nmulti_rast\n## class       : SpatRaster \n## dimensions  : 1428, 1128, 4  (nrow, ncol, nlyr)\n## resolution  : 30, 30  (x, y)\n## extent      : 301905, 335745, 4111245, 4154085  (xmin, xmax, ymin, ymax)\n## coord. ref. : WGS 84 / UTM zone 12N (EPSG:32612) \n## source      : landsat.tif \n## names       : landsat_1, landsat_2, landsat_3, landsat_4 \n## min values  :      7550,      6404,      5678,      5252 \n## max values  :     19071,     22051,     25780,     31961\n\n\nnlyr(multi_rast)\n## [1] 4\n\nLos rásters multicapa se pueden subdividir con el índice o el nombre de las capas deseadas:\n\nmulti_rast3 = subset(multi_rast, 3)\nmulti_rast4 = subset(multi_rast, \"landsat_4\")\n\nSe pueden combinar o concatenar con la función c():\n\nmulti_rast34 = c(multi_rast3, multi_rast4)\nplot(multi_rast34)"
  },
  {
    "objectID": "datos_espaciales_en_R.html#datos-vectoriales",
    "href": "datos_espaciales_en_R.html#datos-vectoriales",
    "title": "Datos espaciales en R",
    "section": "",
    "text": "El modelo de datos vectoriales geográficos se basa en puntos situados dentro de un sistema de referencia de coordenadas (CRS). Los puntos pueden representar características autónomas (por ejemplo, la ubicación de una parada de autobús) o pueden unirse para formar geometrías más complejas, como líneas y polígonos.\n\nEl paquete sf nos permite trabajar con datos vectoriales en R. Simple Features es un estándar abierto desarrollado y aprobado por el Open Geospatial Consortium (OGC). Simple Features es un modelo de datos jerárquico que representa una amplia gama de tipos de geometría. sf puede representar todos los tipos de geometría vectorial habituales (sf no admite clases de datos ráster): puntos, líneas, polígonos y sus respectivas versiones “multi” (que agrupan características del mismo tipo en una única característica). sf también admite colecciones de geometría, que pueden contener múltiples tipos de geometría en un único objeto. Simple features es un modelo de datos ampliamente soportado que subyace en las estructuras de datos de muchas aplicaciones SIG, incluyendo QGIS y PostGIS.\nLa funcionalidad de sf está bien documentada en su sitio web https://r-spatial.github.io/sf/, que contiene 7 viñetas. Estas se pueden ver de la siguiente manera:\n\n#vignette(package = \"sf\") # see which vignettes are available\n#vignette(\"sf1\")          # an introduction to the package\n\n\nLos objetos feature simples en R se almacenan en un data.frame (tabla de datos), con los datos geográficos ocupando una columna especial, normalmente llamada ‘geom’ o ‘geometry’. Utilizaremos el conjunto de datos world proporcionado por spData para mostrar qué son los objetos sf y cómo funcionan.\n\nclass(world)\nnames(world)\nhead(world)\n## [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n##  [1] \"iso_a2\"    \"name_long\" \"continent\" \"region_un\" \"subregion\" \"type\"     \n##  [7] \"area_km2\"  \"pop\"       \"lifeExp\"   \"gdpPercap\" \"geom\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\niso_a2\nname_long\ncontinent\nregion_un\nsubregion\ntype\narea_km2\npop\nlifeExp\ngdpPercap\ngeom\n\n\n\nFJ\nFiji\nOceania\nOceania\nMelanesia\nSovereign country\n19289.97\n885806\n69.96000\n8222.254\nMULTIPOLYGON (((-180 -16.55…\n\n\nTZ\nTanzania\nAfrica\nAfrica\nEastern Africa\nSovereign country\n932745.79\n52234869\n64.16300\n2402.099\nMULTIPOLYGON (((33.90371 -0…\n\n\nEH\nWestern Sahara\nAfrica\nAfrica\nNorthern Africa\nIndeterminate\n96270.60\nNA\nNA\nNA\nMULTIPOLYGON (((-8.66559 27…\n\n\nCA\nCanada\nNorth America\nAmericas\nNorthern America\nSovereign country\n10036042.98\n35535348\n81.95305\n43079.143\nMULTIPOLYGON (((-132.71 54….\n\n\nUS\nUnited States\nNorth America\nAmericas\nNorthern America\nCountry\n9510743.74\n318622525\n78.84146\n51921.985\nMULTIPOLYGON (((-171.7317 6…\n\n\nKZ\nKazakhstan\nAsia\nAsia\nCentral Asia\nSovereign country\n2729810.51\n17288285\n71.62000\n23587.338\nMULTIPOLYGON (((87.35997 49…\n\n\n\n\n\n\nEl contenido de esta columna geom es la que confiere a los objetos sf sus poderes espaciales: world$geom es una “columna lista” de la clase sfc que contiene todas las coordenadas de los polígonos de los países. Los objetos sf pueden visualizarse rápidamente con la función plot()\n\nplot(world)\n\n\n\n\nPodemos obtener info de los atributos (columnas) de los objetos sf, como se hace con cualquier data.frame:\n\nsummary(world[\"lifeExp\"])\n##     lifeExp                 geom    \n##  Min.   :50.62   MULTIPOLYGON :177  \n##  1st Qu.:64.96   epsg:4326    :  0  \n##  Median :72.87   +proj=long...:  0  \n##  Mean   :70.85                      \n##  3rd Qu.:76.78                      \n##  Max.   :83.59                      \n##  NA's   :10\n\nLos objetos sf son fáciles de subdividir. Por ejemplo, podemos recortar sólo las dos primeras filas y las tres primeras columnas del objeto world.\n\nworld_mini = world[1:2, 1:3]\nplot(world_mini)\n\n\n\n\nTambién podemos subdividir por columnas únicamente, ya sea con su índice o el nombre\n\nplot(world[3:6])\n\n\n\nplot(world[\"pop\"])\n\n\n\n\nPodemos hacer selecciones\n\nworld_asia = world[world$continent == \"Asia\", ]\nasia = st_union(world_asia)\n\ny añadir capas a las imágenes existentes estableciendo add = TRUE\n\nplot(world[\"pop\"], reset = FALSE)\nplot(asia, col = \"red\", add = TRUE)\n\n\n\n\nHay varias formas de modificar los mapas con el método plot() de sf. Por ejemplo, se pueden superponer círculos, cuyos diámetros (fijados con cex =) representan poblaciones de países, en un mapa del mundo.\n\nplot(world[\"continent\"], reset = FALSE)\ncex = sqrt(world$pop) / 10000\nworld_cents = st_centroid(world, of_largest = TRUE)\nplot(st_geometry(world_cents), add = TRUE, cex = cex)\n\n\n\n\n\nLas geometrías son los componentes básicos de los objetos sf y pueden adoptar uno de los 18 tipos de geometría que admite el paquete sf. Los siete tipos más utilizados son: PUNTO, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON y GEOMETRYCOLLECTION.\nPor lo general, el usuario se ahorra la tediosa tarea de crear geometrías por su cuenta, ya que puede simplemente importar un archivo espacial ya existente. Sin embargo, existe un conjunto de funciones para crear objetos geométricos de características simples (sfg) desde cero si es necesario. Los nombres de estas funciones son sencillos, todas comienzan con el prefijo st_ y terminan con el nombre del tipo de geometría:\n\nUn punto: st_point()\n\nUna cadena de líneas: st_linestring()\n\nUn polígono: st_polygon()\n\nUn multipunto: st_multipoint()\n\nUna multilínea: st_multilínea()\n\nUn multipolígono: st_multipolygon()\n\nUna colección de geometrías: st_geometrycollection()\n\n\nLos objetos sfg pueden crearse a partir de tres tipos de datos R básicos:\n\nUn vector numérico: un único punto\nUna matriz: un conjunto de puntos, donde cada fila representa un punto, un multipunto o una cadena de líneas\nUna lista: una colección de objetos como matrices, multilíneas o colecciones de geometría."
  },
  {
    "objectID": "datos_espaciales_en_R.html#datos-raster",
    "href": "datos_espaciales_en_R.html#datos-raster",
    "title": "Datos espaciales en R",
    "section": "",
    "text": "El modelo de datos espaciales ráster representa el mundo con la cuadrícula continua de celdas (a menudo también llamadas píxeles). Este modelo de datos se refiere a menudo a las denominadas cuadrículas regulares, en las que cada celda tiene el mismo tamaño constante.\nEl modelo de datos ráster suele constar de una cabecera ráster y una matriz (con filas y columnas) que representa celdas equidistantes (a menudo también denominadas píxeles). La cabecera ráster define el sistema de referencia de coordenadas, la extensión y el origen. El origen (o punto de partida) suele ser la coordenada de la esquina inferior izquierda de la matriz (el paquete terra, sin embargo, utiliza por defecto la esquina superior izquierda). La cabecera define la extensión mediante el número de columnas, el número de filas y la resolución del tamaño de las celdas. De este modo, partiendo del origen, podemos acceder fácilmente a cada celda y modificarla, ya sea utilizando el ID de una celda o especificando explícitamente las filas y columnas. Esta representación matricial evita almacenar explícitamente las coordenadas de los cuatro puntos de esquina (de hecho, sólo almacena una coordenada, el origen) de cada esquina de celda, como ocurriría en el caso de los polígonos vectoriales rectangulares. Sin embargo, a diferencia de los datos vectoriales, la celda de una capa raster sólo puede contener un único valor. El valor puede ser numérico o categórico.\n\nLos mapas raster suelen representar fenómenos continuos como la elevación, la temperatura, la densidad de población o datos espectrales. En el modelo de datos raster también pueden representarse características discretas, como clases de suelo o de cubierta terrestre.\n\n\nEn las dos últimas décadas, se han desarrollado varios paquetes para leer y procesar conjuntos de datos raster. El principal de ellos fue raster, que supuso un cambio radical en las capacidades raster de R cuando se lanzó en 2010 y se convirtió en el principal paquete en este ámbito hasta el desarrollo de terra y stars. Estos últimos, desarrollados más recientemente, ofrecen funciones potentes y eficaces para trabajar con conjuntos de datos ráster, y existe un solapamiento sustancial entre sus posibles casos de uso. Aquí nos vamos a centrar en el paquete terra.\n\nEl paquete terra soporta objetos raster en R. Al igual que su predecesor raster (creado por el mismo desarrollador, Robert Hijmans), proporciona un amplio conjunto de funciones para crear, leer, exportar, manipular y procesar conjuntos de datos raster. La funcionalidad de terra es en gran medida la misma que la del paquete raster, pero hay algunas diferencias: las funciones de terra suelen ser más eficientes computacionalmente. Puede traducir sin problemas entre los dos tipos de objetos para garantizar la compatibilidad con scripts y paquetes más antiguos, por ejemplo, con las funciones raster(), stack() y brick() en el paquete raster.\nAdemás de las funciones para la manipulación de datos ráster, terra proporciona muchas funciones de bajo nivel que pueden constituir una base para el desarrollo de nuevas herramientas para trabajar con conjuntos de datos ráster. terra también le permite trabajar con grandes conjuntos de datos ráster que son demasiado grandes para caber en la memoria principal. En este caso, terra ofrece la posibilidad de dividir el raster en trozos más pequeños, y procesarlos iterativamente en lugar de cargar todo el archivo raster en la RAM.\n\nraster_filepath = system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nmy_rast = rast(raster_filepath)\nclass(my_rast)\n## [1] \"SpatRaster\"\n## attr(,\"package\")\n## [1] \"terra\"\n\n\nmy_rast\n## class       : SpatRaster \n## dimensions  : 457, 465, 1  (nrow, ncol, nlyr)\n## resolution  : 0.0008333333, 0.0008333333  (x, y)\n## extent      : -113.2396, -112.8521, 37.13208, 37.51292  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source      : srtm.tif \n## name        : srtm \n## min value   : 1024 \n## max value   : 2892\n\n\nplot(my_rast)\n\n\n\n\nClases de datos raster\nEl paquete terra soporta numerosos controladores con la ayuda de la biblioteca GDAL. Por lo general, los rásters de los archivos no se leen completamente en la RAM, a excepción de su cabecera y un puntero al archivo.\n\nsingle_raster_file = system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nsingle_rast = rast(raster_filepath)\nsingle_rast\n## class       : SpatRaster \n## dimensions  : 457, 465, 1  (nrow, ncol, nlyr)\n## resolution  : 0.0008333333, 0.0008333333  (x, y)\n## extent      : -113.2396, -112.8521, 37.13208, 37.51292  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source      : srtm.tif \n## name        : srtm \n## min value   : 1024 \n## max value   : 2892\n\nLos rásters también pueden crearse desde cero utilizando la misma función rast().\n\nnew_raster = rast(nrows = 6, ncols = 6, \n                  xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n                  vals = 1:36)\nplot(new_raster)\n\n\n\n\nLa clase SpatRaster también puede manejar múltiples capas, por ejemplo, las bandas de un satélite multiespectral o una serie temporal de rásters.\n\nmulti_raster_file = system.file(\"raster/landsat.tif\", package = \"spDataLarge\")\nmulti_rast = rast(multi_raster_file)\nmulti_rast\n## class       : SpatRaster \n## dimensions  : 1428, 1128, 4  (nrow, ncol, nlyr)\n## resolution  : 30, 30  (x, y)\n## extent      : 301905, 335745, 4111245, 4154085  (xmin, xmax, ymin, ymax)\n## coord. ref. : WGS 84 / UTM zone 12N (EPSG:32612) \n## source      : landsat.tif \n## names       : landsat_1, landsat_2, landsat_3, landsat_4 \n## min values  :      7550,      6404,      5678,      5252 \n## max values  :     19071,     22051,     25780,     31961\n\n\nnlyr(multi_rast)\n## [1] 4\n\nLos rásters multicapa se pueden subdividir con el índice o el nombre de las capas deseadas:\n\nmulti_rast3 = subset(multi_rast, 3)\nmulti_rast4 = subset(multi_rast, \"landsat_4\")\n\nSe pueden combinar o concatenar con la función c():\n\nmulti_rast34 = c(multi_rast3, multi_rast4)\nplot(multi_rast34)"
  },
  {
    "objectID": "interaccion_raster_vector.html",
    "href": "interaccion_raster_vector.html",
    "title": "Interacciones raster-vector",
    "section": "",
    "text": "library(sf)\nlibrary(terra)\nlibrary(dplyr)"
  },
  {
    "objectID": "interaccion_raster_vector.html#introducción",
    "href": "interaccion_raster_vector.html#introducción",
    "title": "Interacciones raster-vector",
    "section": "Introducción",
    "text": "Introducción\nEste capítulo se centra en las interacciones entre los modelos de datos geográficos ráster y vectoriales. Incluye cuatro técnicas principales: recorte y enmascaramiento ráster utilizando objetos vectoriales; extracción de valores ráster utilizando diferentes tipos de datos vectoriales; y conversión ráster-vector."
  },
  {
    "objectID": "interaccion_raster_vector.html#recorte",
    "href": "interaccion_raster_vector.html#recorte",
    "title": "Interacciones raster-vector",
    "section": "Recorte",
    "text": "Recorte\nMuchos proyectos de datos geográficos implican la integración de datos de muchas fuentes diferentes, como imágenes de teledetección (rásters) y límites administrativos (vectores). A menudo, la extensión de los conjuntos de datos ráster de entrada es mayor que el área de interés. En este caso, el recorte y el enmascaramiento ráster son útiles para unificar la extensión espacial de los datos de entrada. Ambas operaciones reducen el uso de memoria del objeto y los recursos computacionales asociados para los pasos de análisis posteriores, y pueden ser un paso de preprocesamiento necesario antes de crear mapas atractivos que incluyan datos ráster.\nUtilizaremos dos objetos para ilustrar el recorte raster:\n\nUn objeto SpatRaster srtm que representa la elevación (metros sobre el nivel del mar) en el suroeste de Utah\nUn objeto vectorial (sf) zion que representa el Parque Nacional de Zion.\n\nTanto el objeto de destino como el de recorte deben tener la misma proyección. Por lo tanto, el siguiente fragmento de código no sólo lee los conjuntos de datos del paquete spDataLarge, sino que también “reproyecta” zion:\n\nsrtm = rast(system.file(\"raster/srtm.tif\", package = \"spDataLarge\"))\nzion = read_sf(system.file(\"vector/zion.gpkg\", package = \"spDataLarge\"))\nzion = st_transform(zion, crs(srtm))\n\nUtilizamos crop() del paquete terra para recortar srtm. La función reduce la extensión rectangular del objeto pasado como primer argumento en función de la extensión del objeto pasado como segundo argumento.\n\nsrtm_cropped = crop(srtm, zion)\n\nRelacionada con crop() está la función terra mask(), que establece como NA los valores fuera de los límites del objeto pasado a su segundo argumento. Por tanto, el siguiente comando enmascara todas las celdas situadas fuera de los límites del Parque Nacional de Zion:\n\nsrtm_masked = mask(srtm, zion)\n\nEs importante destacar que, en la mayoría de los casos, se recomienda utilizar conjuntamente las funciones crop() y mask(). Esta combinación de funciones (a) limitaría la extensión del raster a nuestra área de interés y (b) reemplazaría todos los valores fuera del área a NA.\n\nsrtm_cropped = crop(srtm, zion)\nsrtm_final = mask(srtm_cropped, zion)\n\nCambiando la configuración de mask() se obtienen resultados diferentes. Si se establece inverse = TRUE se enmascarará todo lo que esté dentro de los límites del parque (véase ?mask para más detalles), mientras que si se establece updatevalue = 0 se pondrán a 0 todos los píxeles fuera del parque nacional.\n\nsrtm_inv_masked = mask(srtm, zion, inverse = TRUE)\n\n\n\n\n\nIllustration of raster cropping and raster masking."
  },
  {
    "objectID": "interaccion_raster_vector.html#extracción-de-datos-de-un-raster",
    "href": "interaccion_raster_vector.html#extracción-de-datos-de-un-raster",
    "title": "Interacciones raster-vector",
    "section": "Extracción de datos de un raster",
    "text": "Extracción de datos de un raster\nLa extracción de raster es el proceso de identificar y devolver los valores asociados a un raster “objetivo” en ubicaciones específicas, basándose en un objeto “selector” geográfico (normalmente vectorial). Los resultados dependen del tipo de selector utilizado (puntos, líneas o polígonos) y de los argumentos pasados a la función terra::extract(). El reverso de la extracción raster — asignar valores de celda raster basado en objetos vectoriales — es la rasterización, que se describe más adelante.\nEl ejemplo básico consiste en extraer el valor de una celda ráster en puntos específicos. Para ello, utilizaremos zion_points, que contiene una muestra de 30 localizaciones dentro del Parque Nacional de Zion. El siguiente comando extrae los valores de elevación de srtm y crea un data frame con los ID de los puntos (un valor por fila del vector) y los valores srtm relacionados para cada punto. Ahora, podemos añadir el objeto resultante a nuestro conjunto de datos zion_points con la función cbind():\n\ndata(\"zion_points\", package = \"spDataLarge\")\nelevation = terra::extract(srtm, zion_points)\nzion_points = cbind(zion_points, elevation)\n\n\n\n\n\nLocations of points used for raster extraction.\n\n\n\nLa extracción de datos raster también funciona con selectores de tipo línea. Entonces, extrae un valor por cada celda raster tocada por la línea. El enfoque consiste en dividir la línea en muchos puntos y luego extraer los valores de estos puntos. Para demostrarlo, el código siguiente crea zion_transect, una línea recta que va del noroeste al sureste del Parque Nacional de Zion:\n\nzion_transect = cbind(c(-113.2, -112.9), c(37.45, 37.2)) |&gt;\n  st_linestring() |&gt; \n  st_sfc(crs = crs(srtm)) |&gt;\n  st_sf(geometry = _)\n\nLa utilidad de extraer alturas de un selector lineal se ilustra imaginando que está planeando una excursión. El método que se muestra a continuación proporciona un perfil de elevación de la ruta (no es necesario que la línea sea recta), útil para estimar cuánto tiempo se tardará debido a las subidas.\nEl primer paso es añadir un id único para cada transecto. A continuación, con la función st_segmentize() podemos añadir puntos a lo largo de nuestra(s) línea(s) con una densidad proporcionada (dfMaxLength) y convertirlos en puntos con st_cast().\n\nzion_transect$id = 1:nrow(zion_transect)\nzion_transect = st_segmentize(zion_transect, dfMaxLength = 250)\nzion_transect = st_cast(zion_transect, \"POINT\")\n\nAhora, tenemos un gran conjunto de puntos, y queremos derivar una distancia entre el primer punto de nuestros transectos y cada uno de los puntos subsiguientes. En este caso, sólo tenemos un transecto, pero el código, en principio, debería funcionar con cualquier número de transectos:\n\nzion_transect = zion_transect |&gt; \n  group_by(id) |&gt; \n  mutate(dist = st_distance(geometry)[, 1]) \n\nPor último, podemos extraer los valores de elevación de cada punto de nuestros transectos y combinar esta información con nuestro objeto principal.\n\nzion_elev = terra::extract(srtm, zion_transect)\nzion_transect = cbind(zion_transect, zion_elev)\n\nEl zion_transect resultante puede utilizarse para crear perfiles de elevación, como se ilustra a continuación.\n\n\n\n\nLocation of a line used for raster extraction (left) and the elevation along this line (right).\n\n\n\nEl último tipo de objeto vectorial geográfico para la extracción de rásters son los polígonos. Al igual que las líneas, los polígonos tienden a devolver muchos valores ráster por polígono. Esto se demuestra en el siguiente comando, que da como resultado un marco de datos con nombres de columna ID (el número de fila del polígono) y srtm (valores de elevación asociados):\n\nzion_srtm_values = terra::extract(x = srtm, y = zion)\n\nEstos resultados pueden utilizarse para generar estadísticas resumidas de valores ráster por polígono, por ejemplo para caracterizar una única región o para comparar muchas regiones. Esto se muestra en el siguiente código, que crea el objeto zion_srtm_df que contiene estadísticas resumidas para los valores de elevación en el Parque Nacional de Zion:\n\ngroup_by(zion_srtm_values, ID) |&gt; \n  summarize(across(srtm, list(min = min, mean = mean, max = max)))\n\n\n\n\nID\nsrtm_min\nsrtm_mean\nsrtm_max\n\n\n1\n1122\n1818.212\n2661\n\n\n\n\n\nEl trozo de código anterior utilizó dplyr para proporcionar estadísticas de resumen para los valores de celda por ID de polígono. Los resultados proporcionan resúmenes útiles, por ejemplo, que la altura máxima en el parque es de alrededor de 2.661 metros sobre el nivel del mar (otras estadísticas de resumen, como la desviación estándar, también se puede calcular de esta manera). Como en el ejemplo sólo hay un polígono, se devuelve una tabla de datos con una única fila; sin embargo, el método funciona cuando se utilizan varios polígonos selectores.\nUn método similar funciona para el recuento de ocurrencias de valores ráster categóricos dentro de polígonos. Esto se ilustra con un conjunto de datos de cobertura del suelo (nlcd) del paquete spDataLarge, y se demuestra en el código siguiente:\n\nnlcd = rast(system.file(\"raster/nlcd.tif\", package = \"spDataLarge\"))\nzion2 = st_transform(zion, st_crs(nlcd))\nzion_nlcd = terra::extract(nlcd, zion2)\nzion_nlcd |&gt; \n  group_by(ID, levels) |&gt;\n  count()\n\n\n\n\nID\nlevels\nn\n\n\n\n1\nDeveloped\n4205\n\n\n1\nBarren\n98285\n\n\n1\nForest\n298299\n\n\n1\nShrubland\n203700\n\n\n1\nHerbaceous\n235\n\n\n1\nCultivated\n62\n\n\n1\nWetlands\n679\n\n\n\n\n\n\n\n\n\n\nArea used for continuous (left) and categorical (right) raster extraction.\n\n\n\nAunque el paquete terra ofrece una rápida extracción de valores ráster dentro de polígonos, extract() puede seguir siendo un cuello de botella cuando se procesan grandes conjuntos de datos de polígonos. El paquete exactextractr ofrece una alternativa significativamente más rápida para extraer valores de píxeles a través de la función exact_extract(). La función exact_extract() también calcula, por defecto, la fracción de cada celda ráster solapada por el polígono, lo cual es más preciso.\n\n\n\n\n\n\nNota\n\n\n\nLos polígonos suelen tener formas irregulares y, por lo tanto, un polígono puede solapar sólo algunas partes de las celdas de un ráster. Para obtener resultados más detallados, la función terra::extract() tiene un argumento llamado exact. Con exact = TRUE, obtenemos una columna más fraction en el marco de datos de salida, que representa una fracción de cada celda que está cubierta por el polígono. Esto podría ser útil para calcular, por ejemplo, una media ponderada para rásters continuos o una cobertura más precisa para rásters categóricos. Por defecto, es FALSE ya que esta operación requiere más cálculos. La función exactextractr::exact_extract() siempre calcula la fracción de cobertura del polígono en cada celda."
  },
  {
    "objectID": "interaccion_raster_vector.html#rasterización",
    "href": "interaccion_raster_vector.html#rasterización",
    "title": "Interacciones raster-vector",
    "section": "Rasterización",
    "text": "Rasterización\nLa rasterización es la conversión de objetos vectoriales a raster. Normalmente, el ráster de salida se utiliza después para análisis cuantitativos (por ejemplo, análisis del terreno) o modelado. El proceso de rasterización puede ayudar a simplificar los conjuntos de datos porque todos los valores resultantes tienen la misma resolución espacial: la rasterización puede considerarse un tipo especial de agregación de datos geográficos.\nEl paquete terra contiene la función rasterize() para realizar este trabajo. Sus dos primeros argumentos son, x, objeto vectorial a rasterizar e, y, un objeto `plantilla raster’ que define la extensión, resolución y CRS de la salida. La resolución geográfica del ráster de entrada tiene un gran impacto en los resultados: si es demasiado baja (el tamaño de las celdas es demasiado grande), el resultado puede perder toda la variabilidad geográfica de los datos vectoriales; si es demasiado alta, los tiempos de cálculo pueden ser excesivos. No existen reglas sencillas a la hora de decidir la resolución geográfica adecuada, que depende en gran medida del uso que se pretenda dar a los resultados. A menudo, la resolución objetivo se impone al usuario, por ejemplo cuando el resultado de la rasterización debe alinearse con algún otro raster existente.\nPara demostrar la rasterización en acción, utilizaremos una plantilla raster que tiene la misma extensión y CRS que los datos vectoriales de entrada cycle_hire_osm_projected y una resolución espacial de 1000 metros:\n\ncycle_hire_osm = spData::cycle_hire_osm\ncycle_hire_osm_projected = st_transform(cycle_hire_osm, \"EPSG:27700\")\nraster_template = rast(ext(cycle_hire_osm_projected), resolution = 1000,\n                       crs = st_crs(cycle_hire_osm_projected)$wkt)\n\nLa rasterización es una operación muy flexible: los resultados dependen no sólo de la naturaleza de la plantilla raster, sino también del tipo de vector de entrada (por ejemplo, puntos, polígonos) y de una variedad de argumentos tomados por la función rasterize().\nPara ilustrar esta flexibilidad, probaremos tres enfoques diferentes de la rasterización. En primer lugar, crearemos un raster que represente la presencia o ausencia de puntos de alquiler de bicicletas (conocidos como raster de presencia/ausencia). En este caso, rasterize() no requiere ningún argumento además de x e y, los objetos vector y raster antes mencionados.\n\nch_raster1 = rasterize(cycle_hire_osm_projected, raster_template)\n\nEl argumento fun especifica los estadísticos de resumen utilizados para convertir múltiples observaciones muy próximas en celdas asociadas en el objeto raster. Por defecto se utiliza fun = \"last\" pero se pueden utilizar otras opciones como fun = \"length\", en este caso para contar el número de puntos de alquiler de ciclos en cada celda de la cuadrícula.\n\nch_raster2 = rasterize(cycle_hire_osm_projected, raster_template, \n                       fun = \"length\")\n\nEl nuevo resultado, ch_raster2, muestra el número de puntos de alquiler de bicicletas en cada cuadrícula. Los puntos de alquiler de bicicletas tienen diferentes números de bicicletas descritos por la variable capacity, lo que plantea la siguiente pregunta: ¿cuál es la capacidad de cada celda de la cuadrícula? Para calcularlo debemos “sumar” el campo (\"capacity\"), calculada con el siguiente comando (también se podrían utilizar otras funciones de resumen como mean):\n\nch_raster3 = rasterize(cycle_hire_osm_projected, raster_template, \n                       field = \"capacity\", fun = sum, na.rm = TRUE)\n\n\n\n\n\nExamples of point rasterization.\n\n\n\nOtro conjunto de datos basado en polígonos y fronteras de California ilustra la rasterización de líneas. Tras fundir los objetos poligonales en una multilínea, se crea un raster de plantilla con una resolución de 0.5 grados:\n\nlibrary(spData)\ncalifornia = dplyr::filter(us_states, NAME == \"California\")\ncalifornia_borders = st_cast(california, \"MULTILINESTRING\")\nraster_template2 = rast(ext(california), resolution = 0.5,\n                        crs = st_crs(california)$wkt)\n\nAl considerar la rasterización de líneas o polígonos, un argumento adicional útil es “touches”. Por defecto es FALSE, pero cuando se cambia a TRUE – todas las celdas que son tocadas por el borde de una línea o polígono obtienen un valor. La rasterización de líneas con touches = TRUE se muestra en el siguiente código.\n\ncalifornia_raster1 = rasterize(california_borders, raster_template2,\n                               touches = TRUE)\n\nCompárelo con una rasterización de polígonos, con touches = FALSE por defecto, que selecciona sólo las celdas raster cuyos centroides están dentro del polígono selector.\n\ncalifornia_raster2 = rasterize(california, raster_template2) \n\n\n\n\n\nExamples of line and polygon rasterizations."
  },
  {
    "objectID": "interaccion_raster_vector.html#vectorización-espacial",
    "href": "interaccion_raster_vector.html#vectorización-espacial",
    "title": "Interacciones raster-vector",
    "section": "Vectorización espacial",
    "text": "Vectorización espacial\nLa vectorización espacial es la contrapartida de la rasterización. Consiste en convertir datos ráster espacialmente continuos en datos vectoriales espacialmente discretos, como puntos, líneas o polígonos.\n\n\n\n\n\n\nNota\n\n\n\nEn R, la vectorización suele referirse a la posibilidad de sustituir los bucles for y similares haciendo cosas como 1:10 / 2.\n\n\nLa forma más simple de vectorización es convertir los centroides de las celdas raster en puntos. as.points() hace exactamente esto para todas las celdas de cuadrícula raster que no sean NA. Tenga en cuenta que aquí también utilizamos st_as_sf() para convertir el objeto resultante a la clase sf.\n\nelev = rast(system.file(\"raster/elev.tif\", package = \"spData\"))\nelev_point = as.points(elev) |&gt; \n  st_as_sf()\n\n\n\n\n\nRaster and point representation of the elev object.\n\n\n\nOtro tipo común de vectorización espacial es la creación de curvas de nivel que representen líneas de altura o temperaturas continuas (isotermas), por ejemplo. Utilizaremos un modelo digital de elevación (MDE) del mundo real porque el ráster artificial elev produce líneas paralelas. Las curvas de nivel se pueden crear con la función terra as.contour(), que es a su vez una envoltura de la función incorporada en R filled.contour(), como se demuestra a continuación:\n\ndem = rast(system.file(\"raster/dem.tif\", package = \"spDataLarge\"))\ncl = as.contour(dem) |&gt; \n  st_as_sf()\nplot(dem, axes = FALSE)\nplot(cl, add = TRUE)\n\n\n\n\nTambién pueden añadirse contornos a los gráficos existentes con funciones como contour(), rasterVis::contourplot() o tmap::tm_iso() y, las isolíneas pueden etiquetarse.\n\n\n\n\nDEM with hillshading, showing the southern flank of Mt. Mongón overlaid with contour lines.\n\n\n\nEl último tipo de vectorización implica la conversión de rásters en polígonos. Esto puede hacerse con terra::as.polygons(), que convierte cada celda ráster en un polígono formado por cinco coordenadas, todas las cuales se almacenan en memoria (¡explicando por qué los rásters son a menudo rápidos comparados con los vectores!).\nEsto se ilustra a continuación convirtiendo el objeto grain en polígonos y disolviendo posteriormente los bordes entre polígonos con los mismos valores de atributo (véase también el argumento dissolve en as.polygons()).\n\ngrain = rast(system.file(\"raster/grain.tif\", package = \"spData\"))\ngrain_poly = as.polygons(grain) |&gt; \n  st_as_sf()\n\n\n\n\n\nIllustration of vectorization of raster (left) into polygons (dissolve = FALSE; center) and aggregated polygons (dissolve = TRUE; right)."
  },
  {
    "objectID": "operaciones_geometricas.html",
    "href": "operaciones_geometricas.html",
    "title": "Operaciones geométricas",
    "section": "",
    "text": "library(sf)\nlibrary(terra)\nlibrary(dplyr)\nlibrary(spData)\nlibrary(spDataLarge)"
  },
  {
    "objectID": "operaciones_geometricas.html#introducción",
    "href": "operaciones_geometricas.html#introducción",
    "title": "Operaciones geométricas",
    "section": "Introducción",
    "text": "Introducción\nHasta ahora, hemos visto la estructura de los conjuntos de datos geográficos, y cómo manipularlos basándose en sus atributos no geográficos y relaciones espaciales. Este capítulo se centra en la manipulación de los elementos geográficos de los objetos geográficos, por ejemplo simplificando y convirtiendo geometrías vectoriales, recortando conjuntos de datos ráster y convirtiendo objetos vectoriales en rásteres y rásteres en vectores."
  },
  {
    "objectID": "operaciones_geometricas.html#operaciones-geométricas-sobre-datos-vectoriales",
    "href": "operaciones_geometricas.html#operaciones-geométricas-sobre-datos-vectoriales",
    "title": "Operaciones geométricas",
    "section": "Operaciones geométricas sobre datos vectoriales",
    "text": "Operaciones geométricas sobre datos vectoriales\nEsta sección trata de las operaciones que de alguna manera cambian la geometría de los objetos vectoriales (sf). Es más avanzada que las operaciones con datos espaciales presentadas anteriormente, porque aquí profundizamos en la geometría: las funciones discutidas en esta sección trabajan sobre objetos de clase sfc además de sobre objetos de clase sf.\nSimplificación\nLa simplificación es un proceso de generalización de objetos vectoriales (líneas y polígonos) que suele utilizarse en mapas de menor escala. Otra razón para simplificar objetos es reducir la cantidad de memoria, espacio en disco y ancho de banda de red que consumen: puede ser conveniente simplificar geometrías complejas antes de publicarlas como mapas interactivos. El paquete sf proporciona st_simplify(), que utiliza la implementación GEOS del algoritmo Douglas-Peucker para reducir el número de vértices. st_simplify() utiliza dTolerance para controlar el nivel de generalización en las unidades del mapa. La figura de abajo ilustra la simplificación de una geometría LINESTRING que representa el río Sena y sus afluentes. La geometría simplificada se creó mediante el siguiente comando:\n\nseine_simp = st_simplify(seine, dTolerance = 2000)  # 2000 m\n\n\n\n\n\nComparison of the original and simplified geometry of the seine object.\n\n\n\nEl objeto seine_simp resultante es una copia del seine original pero con menos vértices.\nLa simplificación también es aplicable a los polígonos. Esto se ilustra utilizando us_states, que representa los Estados Unidos contiguos. GEOS asume que los datos están en un CRS proyectado y esto podría llevar a resultados inesperados cuando se utiliza un CRS geográfico. Por lo tanto, el primer paso es proyectar los datos en algún CRS proyectado adecuado, como US National Atlas Equal Area (EPSG = 2163):\n\nus_states2163 = st_transform(us_states, \"EPSG:2163\")\n\nst_simplify() funciona igualmente bien con polígonos proyectados:\n\nus_states_simp1 = st_simplify(us_states2163, dTolerance = 100000)  # 100 km\n\nUna limitación de st_simplify() es que simplifica los objetos por geometría. Esto significa que se pierde la “topología”, lo que da lugar a la superposición y unidades areales con huecos. ms_simplify() de rmapshaper proporciona una alternativa que supera este problema. Por defecto utiliza el algoritmo Visvalingam, que supera algunas limitaciones del algoritmo Douglas-Peucker. El siguiente trozo de código utiliza esta función para simplificar us_states2163. El resultado tiene sólo el 1% de los vértices de la entrada (fijados usando el argumento keep) pero su número de objetos permanece intacto porque fijamos keep_shapes = TRUE:1\n\n# proportion of points to retain (0-1; default 0.05)\nus_states_simp2 = rmapshaper::ms_simplify(us_states2163, keep = 0.01,\n                                          keep_shapes = TRUE)\n\nUna alternativa a la simplificación es el suavizado de los límites de las geometrías poligonales y lineales, que se implementa en el paquete smoothr. El suavizado interpola los bordes de las geometrías y no conduce necesariamente a un menor número de vértices, pero puede ser especialmente útil cuando se trabaja con geometrías que surgen de vectorizar espacialmente un raster. smoothr implementa tres técnicas de suavizado: una regresión kernel gaussiana, el algoritmo de corte de esquinas de Chaikin y la interpolación spline. Los algoritmos de suavizado tampoco conservan la “topología”. La función principal de smoothr es smooth(), donde el argumento method especifica qué técnica de suavizado utilizar. A continuación se muestra un ejemplo de uso de la regresión kernel gaussiana para suavizar las fronteras de los estados de EE.UU. utilizando method=ksmooth. El argumento smoothness controla el ancho de banda de la gaussiana que se utiliza para suavizar la geometría y tiene un valor por defecto de 1.\n\nus_states_simp3 = smoothr::smooth(us_states2163, \n                                  method = \"ksmooth\", smoothness = 6)\n\nLa comparación visual del conjunto de datos original con las versiones simplificada y suavizada se muestra abajo. Pueden observarse diferencias entre los resultados de los algoritmos Douglas-Peucker (st_simplify), Visvalingam (ms_simplify) y regresión kernel gaussiana (smooth(method=ksmooth).\n\n\n\n\nPolygon simplification in action, comparing the original geometry of the contiguous United States with simplified versions, generated with functions from sf (top-right), rmapshaper (bottom-left), and smoothr (bottom-right) packages.\n\n\n\nCentroides\nLas operaciones de centroide identifican el centro de los objetos geográficos. Al igual que las medidas estadísticas de tendencia central, existen muchas formas de definir el centro geográfico de un objeto. Todas ellas crean representaciones de punto único de objetos vectoriales más complejos.\nLa operación de centroide más utilizada es el centroide geográfico. Este tipo de operación centroide representa el centro de masa de un objeto espacial. Los centroides geográficos tienen muchos usos, por ejemplo para crear una representación simple de puntos de geometrías complejas, o para estimar distancias entre polígonos. Pueden calcularse con la función sf st_centroid(), como se demuestra en el código siguiente, que genera los centroides geográficos de regiones de Nueva Zelanda y afluentes del río Sena, ilustrados con puntos negros.\n\nnz_centroid = st_centroid(nz)\nseine_centroid = st_centroid(seine)\n\nA veces, el centroide geográfico cae fuera de los límites de sus objetos padre (piense en un donut). En tales casos, las operaciones punto sobre superficie pueden utilizarse para garantizar que el punto se encuentra en el objeto padre (por ejemplo, para etiquetar objetos multipoligonales irregulares como los estados insulares), como ilustran los puntos rojos de la figura abajo. Observe que estos puntos rojos siempre se encuentran en sus objetos padre. Se crearon con st_point_on_surface() de la siguiente manera:\n\nnz_pos = st_point_on_surface(nz)\nseine_pos = st_point_on_surface(seine)\n\n\n\n\n\nCentroids (black points) and ‘points on surface’ (red points) of New Zealand’s regions (left) and the Seine (right) datasets.\n\n\n\nBuffers\nLos buffers son polígonos que representan el área dentro de una distancia determinada de un elemento geométrico: independientemente de si la entrada es un punto, una línea o un polígono, la salida es un polígono. El buffering suele utilizarse para el análisis de datos geográficos. ¿Cuántos puntos se encuentran a una distancia determinada de esta línea? ¿Qué grupos demográficos se encuentran a una distancia de viaje de esta nueva tienda? Este tipo de preguntas pueden responderse y visualizarse creando buffers alrededor de las entidades geográficas de interés.\nLa próxima figura ilustra los buffers de diferentes tamaños (5 y 50 km) que rodean el río Sena y sus afluentes. Estos buffers se crearon con los comandos que se indican a continuación, que muestran que el comando st_buffer() requiere al menos dos argumentos: una geometría de entrada y una distancia, proporcionada en las unidades del CRS (en este caso metros):\n\nseine_buff_5km = st_buffer(seine, dist = 5000)\nseine_buff_50km = st_buffer(seine, dist = 50000)\n\n\n\n\n\nBuffers around the Seine dataset of 5 km (left) and 50 km (right). Note the colors, which reflect the fact that one buffer is created per geometry feature.\n\n\n\nTransformaciones afines\nUna transformación afín es cualquier transformación que conserva las líneas y el paralelismo. Sin embargo, los ángulos o la longitud no se conservan necesariamente. Las transformaciones afines incluyen, entre otras, el desplazamiento (traslación), la escala y la rotación. Además, es posible utilizar cualquier combinación de ellas. Las transformaciones afines son una parte esencial de la geocomputación. Por ejemplo, el desplazamiento es necesario para la colocación de etiquetas, el escalado se utiliza en cartogramas de áreas no contiguas, y muchas transformaciones afines se aplican al reproyectar o mejorar la geometría que se creó basándose en un mapa distorsionado o mal proyectado. El paquete sf implementa transformaciones afines para objetos de las clases sfg y sfc.\n\nnz_sfc = st_geometry(nz)\n\nEl desplazamiento mueve cada punto la misma distancia en unidades de mapa. Puede hacerse añadiendo un vector numérico a un objeto vectorial. Por ejemplo, el código siguiente desplaza todas las coordenadas y 100.000 metros hacia el norte, pero deja intactas las coordenadas x.\n\nnz_shift = nz_sfc + c(0, 100000)\n\nLa escala amplía o reduce los objetos en un factor dado. Puede aplicarse global o localmente. El escalado global aumenta o disminuye todos los valores de las coordenadas en relación con las coordenadas de origen, manteniendo intactas todas las relaciones topológicas de las geometrías. Puede realizarse por sustracción o multiplicación de un objeto sfg o sfc.\nEl escalado local trata las geometrías de forma independiente y requiere puntos alrededor de los cuales se van a escalar las geometrías, por ejemplo, los centroides. En el ejemplo siguiente, cada geometría se reduce en un factor de dos alrededor de los centroides. Para ello, primero se desplaza cada objeto de modo que su centro tenga coordenadas 0, 0 ((nz_sfc - nz_centroid_sfc)). A continuación, los tamaños de las geometrías se reducen a la mitad (* 0,5). Por último, el centroide de cada objeto se desplaza a las coordenadas de los datos de entrada (+ nz_centroid_sfc).\n\nnz_centroid_sfc = st_centroid(nz_sfc)\nnz_scale = (nz_sfc - nz_centroid_sfc) * 0.5 + nz_centroid_sfc\n\nLa rotación de coordenadas bidimensionales requiere una matriz de rotación:\n\\[\nR =\n\\begin{bmatrix}\n\\cos \\theta & -\\sin \\theta \\\\  \n\\sin \\theta & \\cos \\theta \\\\\n\\end{bmatrix}\n\\]\nÉsta gira los puntos en el sentido de las agujas del reloj. La matriz de rotación se puede implementar en R como:\n\nrotation = function(a){\n  r = a * pi / 180 #degrees to radians\n  matrix(c(cos(r), sin(r), -sin(r), cos(r)), nrow = 2, ncol = 2)\n} \n\nLa función rotation acepta un argumento a - un ángulo de rotación en grados. La rotación puede realizarse alrededor de puntos seleccionados, como los centroides.\n\nnz_rotate = (nz_sfc - nz_centroid_sfc) * rotation(30) + nz_centroid_sfc\n\n\n\n\n\nIllustrations of affine transformations: shift, scale and rotate.\n\n\n\nPor último, las geometrías recién creadas pueden sustituir a las antiguas con la función st_set_geometry():\n\nnz_scale_sf = st_set_geometry(nz, nz_scale)\n\nClipping\nEl recorte espacial es una forma de subset espacial que implica cambios en las columnas geometry de al menos algunas de las características afectadas.\nEl recorte sólo puede aplicarse a características más complejas que los puntos: líneas, polígonos y sus equivalentes “multi”. Para ilustrar el concepto, empezaremos con un ejemplo sencillo: dos círculos superpuestos con un punto central a una unidad de distancia el uno del otro y un radio de uno.\n\nb = st_sfc(st_point(c(0, 1)), st_point(c(1, 1))) # create 2 points\nb = st_buffer(b, dist = 1) # convert points to circles\nplot(b, border = \"grey\")\ntext(x = c(-0.5, 1.5), y = 1, labels = c(\"x\", \"y\"), cex = 3) # add text\n\n\n\nOverlapping circles.\n\n\n\nImagina que quieres seleccionar no un círculo u otro, sino el espacio cubierto por x y y. Para ello se utiliza la función st_intersection(), ilustrada con objetos denominados x e y, que representan los círculos izquierdo y derecho.\n\nx = b[1]\ny = b[2]\nx_and_y = st_intersection(x, y)\nplot(b, border = \"grey\")\nplot(x_and_y, col = \"lightgrey\", border = \"grey\", add = TRUE) # intersecting area\n\n\n\nOverlapping circles with a gray color indicating intersection between them.\n\n\n\nEl siguiente fragmento de código demuestra cómo funciona esto para todas las combinaciones del diagrama de Venn que representan x e y, inspirado en la Figura 5.1 del libro R for Data Science.\n\n\n\n\nSpatial equivalents of logical operators.\n\n\n\nSubsetting y clipping\nRecortar objetos puede cambiar su geometría, pero también puede subdividir objetos, devolviendo sólo las características que se cruzan (o se cruzan parcialmente) con un objeto de recorte/subconjunto. Para ilustrar este punto, vamos a subdividir puntos que cubren el cuadro delimitador de los círculos x e y en la figura anterior. Algunos puntos estarán dentro de un solo círculo, otros dentro de los dos y otros dentro de ninguno. A continuación se utiliza st_sample() para generar una distribución aleatoria de puntos dentro de la extensión de los círculos x e y, planteando la siguiente pregunta: ¿cómo subconjuntar los puntos para devolver sólo el punto que se cruza con ambos x e y?\n\nbb = st_bbox(st_union(x, y))\nbox = st_as_sfc(bb)\nset.seed(2017)\np = st_sample(x = box, size = 10)\np_xy1 = p[x_and_y]\nplot(box, border = \"grey\", lty = 2)\nplot(x, add = TRUE, border = \"grey\")\nplot(y, add = TRUE, border = \"grey\")\nplot(p, add = TRUE)\nplot(p_xy1, cex = 3, col = \"red\", add = TRUE)\ntext(x = c(-0.5, 1.5), y = 1, labels = c(\"x\", \"y\"), cex = 2)\n\n\n\nRandomly distributed points within the bounding box enclosing circles x and y. The point that intersects with both objects x and y is highlighted.\n\n\n\n\nbb = st_bbox(st_union(x, y))\nbox = st_as_sfc(bb)\nset.seed(2017)\np = st_sample(x = box, size = 10)\nx_and_y = st_intersection(x, y)\n\nEl siguiente fragmento de código muestra tres formas de conseguir el mismo resultado. Podemos utilizar la intersección de x y y (representados por x_and_y en el fragmento de código anterior) como un objeto de subconjunto directamente, como se muestra en la primera línea en el fragmento de código a continuación. También podemos encontrar la intersección entre los puntos de entrada representados por p y el objeto de subconjunto/recorte x_and_y, como se muestra en la segunda línea del fragmento de código siguiente. Este segundo enfoque devolverá características que se intersecan parcialmente con x_and_y pero con geometrías modificadas para características espacialmente extensas que cruzan la frontera del objeto de subconjunto. El tercer enfoque consiste en crear un objeto de subconjunto utilizando el predicado espacial binario st_intersects(). Los resultados son idénticos (salvo diferencias superficiales en los nombres de los atributos), pero la implementación difiere sustancialmente:\n\np_xy1 = p[x_and_y] # way #1\np_xy2 = st_intersection(p, x_and_y) # way #2\nsel_p_xy = st_intersects(p, x, sparse = FALSE)[, 1] & \n  st_intersects(p, y, sparse = FALSE)[, 1] # way #3\np_xy3 = p[sel_p_xy]\n\nUniones geométricas\nLa agregación espacial puede disolver silenciosamente las geometrías de los polígonos que se tocan en el mismo grupo. Esto se demuestra en el fragmento de código siguiente, en el que 49 us_states se agregan en cuatro regiones utilizando las funciones base y dplyr:\n\nregions = aggregate(x = us_states[, \"total_pop_15\"], by = list(us_states$REGION),\n                    FUN = sum, na.rm = TRUE)\nregions2 = us_states |&gt; \n  group_by(REGION) |&gt;\n  summarize(pop = sum(total_pop_15, na.rm = TRUE))\n\n\n\n\n\nSpatial aggregation on contiguous polygons, illustrated by aggregating the population of US states into regions, with population represented by color. Note the operation automatically dissolves boundaries between states.\n\n\n\n¿Qué ocurre con las geometrías? Entre bastidores, tanto aggregate() como summarize() combinan las geometrías y disuelven los límites entre ellas utilizando st_union(). Esto se demuestra en el fragmento de código siguiente, que crea un oeste de EE.UU. unido:\n\nus_west = us_states[us_states$REGION == \"West\", ]\nus_west_union = st_union(us_west)\n\nLa función puede tomar dos geometrías y unirlas, como se demuestra en el siguiente fragmento de código que crea un bloque occidental unido que incorpora Texas:\n\ntexas = us_states[us_states$NAME == \"Texas\", ]\ntexas_union = st_union(us_west_union, texas)\n\nTransformaciones de tipo\nGeometry casting es una potente operación que permite transformar el tipo de geometría. Está implementada en la función st_cast() del paquete sf. Es importante destacar que st_cast() se comporta de forma diferente en objetos de geometría simple (sfg) y objetos de geometría simple en columna (sfc).\nVamos a crear un multipunto para ilustrar cómo funciona el cambio de geometría en objetos de geometría simple (sfg):\n\nmultipoint = st_multipoint(matrix(c(1, 3, 5, 1, 3, 1), ncol = 2))\n\nEn este caso, st_cast() puede ser útil para transformar el nuevo objeto en una cadena de líneas o un polígono:\n\nlinestring = st_cast(multipoint, \"LINESTRING\")\npolyg = st_cast(multipoint, \"POLYGON\")\n\n\n\n\n\nExamples of a linestring and a polygon casted from a multipoint geometry.\n\n\n\nLa conversión de multipunto a cadena de líneas es una operación habitual que crea un objeto de línea a partir de observaciones de puntos ordenados, como mediciones GPS o medios geoetiquetados. Esto, a su vez, permite realizar operaciones espaciales como el cálculo de la longitud del camino recorrido. La conversión de multipunto o cadena de líneas a polígono se utiliza a menudo para calcular un área, por ejemplo a partir del conjunto de mediciones GPS tomadas alrededor de un lago o de las esquinas de un solar.\nEl proceso de transformación también puede invertirse utilizando st_cast():\n\nmultipoint_2 = st_cast(linestring, \"MULTIPOINT\")\nmultipoint_3 = st_cast(polyg, \"MULTIPOINT\")\nall.equal(multipoint, multipoint_2)\nall.equal(multipoint, multipoint_3)\n## [1] TRUE\n## [1] TRUE\n\n\n\n\n\n\n\nNota\n\n\n\nPara geometrías simples (sfg), st_cast() también permite pasar geometrías de no multitipos a multitipos (por ejemplo, de POINT a MULTIPOINT) y de multitipos a no multitipos. Sin embargo, al pasar de multitipos a no multitipos, sólo el primer elemento del objeto antiguo permanecerá en el objeto de salida.\n\n\nLa conversión geométrica de la columna geométrica de características simples (sfc) y los objetos de características simples funciona igual que para sfg en la mayoría de los casos. Una diferencia importante es la conversión de multitipos a no multitipos. Como resultado de este proceso, los objetos múltiples de sfc o sf se dividen en muchos objetos no múltiples.\nLa tabla de abajo muestra las posibles transformaciones del tipo de geometría en objetos sf. Las geometrías de sf (representadas por la primera columna de la tabla) pueden transformarse en múltiples tipos de geometría, representados por las columnas de la tabla abajo. Algunas transformaciones no son posibles: no se puede convertir un único punto en una multilínea o un polígono, por ejemplo, lo que explica por qué las celdas [1, 4:5] de la tabla contienen NA. Algunas transformaciones dividen la entrada de una única característica en múltiples subcaracterísticas, “expandiendo” objetos sf (añadiendo nuevas filas con valores de atributos duplicados). Cuando una geometría multipunto que consta de cinco pares de coordenadas se transforma en una geometría “PUNTO”, por ejemplo, la salida contendrá cinco características.\n\n\n\nGeometry casting on simple feature geometries (see Section 2.1) with input type by row and output type by column\n\n\nPOI\nMPOI\nLIN\nMLIN\nPOL\nMPOL\nGC\n\n\n\nPOI(1)\n1\n1\n1\nNA\nNA\nNA\nNA\n\n\nMPOI(1)\n4\n1\n1\n1\n1\nNA\nNA\n\n\nLIN(1)\n5\n1\n1\n1\n1\nNA\nNA\n\n\nMLIN(1)\n7\n2\n2\n1\nNA\nNA\nNA\n\n\nPOL(1)\n5\n1\n1\n1\n1\n1\nNA\n\n\nMPOL(1)\n10\n1\nNA\n1\n2\n1\n1\n\n\nGC(1)\n9\n1\nNA\nNA\nNA\nNA\n1\n\n\n\n\n Note: Values like (1) represent the number of features; NA means the operation is not possible. Abbreviations: POI, LIN, POL and GC refer to POINT, LINESTRING, POLYGON and GEOMETRYCOLLECTION. The MULTI version of these geometry types is indicated by a preceding M, e.g., MPOI is the acronym for MULTIPOINT.\n\n\n\n\n\n\n\n\n\n\n\nIntentemos aplicar transformaciones de tipo geométrico sobre un nuevo objeto, multilinestring_sf, como ejemplo :\n\nmultilinestring_list = list(matrix(c(1, 4, 5, 3), ncol = 2), \n                            matrix(c(4, 4, 4, 1), ncol = 2),\n                            matrix(c(2, 4, 2, 2), ncol = 2))\nmultilinestring = st_multilinestring(multilinestring_list)\nmultilinestring_sf = st_sf(geom = st_sfc(multilinestring))\nmultilinestring_sf\n\n\n\n\n\n\ngeom\n\n\n\n\nMULTILINESTRING ((1 5, 4 3)…\n\n\n\n\n\n\nPuede imaginárselo como una red de carreteras o ríos. El nuevo objeto sólo tiene una fila que define todas las líneas. Esto restringe el número de operaciones que se pueden realizar, por ejemplo impide añadir nombres a cada segmento de línea o calcular longitudes de líneas individuales. La función st_cast() puede utilizarse en esta situación, ya que separa una mutlilínea en tres líneas:\n\nlinestring_sf2 = st_cast(multilinestring_sf, \"LINESTRING\")\nlinestring_sf2\n\n\n\n\n\n\ngeom\n\n\n\n\n\nLINESTRING (1 5, 4 3)\n\n\n\n\nLINESTRING (4 4, 4 1)\n\n\n\n\nLINESTRING (2 2, 4 2)\n\n\n\n\n\n\n\n\n\n\n\nExamples of type casting between MULTILINESTRING (left) and LINESTRING (right).\n\n\n\nEl objeto recién creado permite la creación de atributos y mediciones de longitud:\n\nlinestring_sf2$name = c(\"Riddle Rd\", \"Marshall Ave\", \"Foulke St\")\nlinestring_sf2$length = st_length(linestring_sf2)\nlinestring_sf2\n\n\n\n\n\n\ngeom\n\n\nname\n\n\nlength\n\n\n\n\n\nLINESTRING (1 5, 4 3)\n\n\nRiddle Rd\n\n\n3.605551\n\n\n\n\nLINESTRING (4 4, 4 1)\n\n\nMarshall Ave\n\n\n3.000000\n\n\n\n\nLINESTRING (2 2, 4 2)\n\n\nFoulke St\n\n\n2.000000"
  },
  {
    "objectID": "operaciones_geometricas.html#operaciones-geométricas-sobre-datos-raster",
    "href": "operaciones_geometricas.html#operaciones-geométricas-sobre-datos-raster",
    "title": "Operaciones geométricas",
    "section": "Operaciones geométricas sobre datos raster",
    "text": "Operaciones geométricas sobre datos raster\nLas operaciones geométricas ráster incluyen el desplazamiento, la inversión, el reflejo, la escala, la rotación o la deformación de imágenes. Estas operaciones son necesarias para diversas aplicaciones, como la georreferenciación, que permite superponer imágenes en un mapa con un CRS conocido. Existen diversas técnicas de georreferenciación, entre las que se incluyen:\n\nGeorrectificación basada en puntos de control terrestre conocidos\n\nOrtorectificación, que también tiene en cuenta la topografía local\nEl co-registro de imágenes se utiliza para combinar imágenes del mismo objeto pero tomadas con sensores diferentes, alineando una imagen con otra (en términos de sistema de coordenadas y resolución).\n\nR es bastante inadecuado para los dos primeros puntos, ya que a menudo requieren una intervención manual, por lo que suelen realizarse con la ayuda de software SIG específico. Por otro lado, alinear varias imágenes es posible en R y esta sección muestra, entre otras cosas, cómo hacerlo. Esto incluye a menudo cambiar la extensión, la resolución y el origen de una imagen. Por supuesto, también se requiere una proyección que coincida.\nIntersecciones geométricas\nHemos mostrado cómo extraer valores de un ráster superpuesto por otros objetos espaciales. Para recuperar una salida espacial, podemos utilizar casi la misma sintaxis de subset. La única diferencia es que tenemos que dejar claro que queremos mantener la estructura matricial estableciendo el argumento drop en FALSE. Esto devolverá un objeto raster que contiene las celdas cuyos puntos medios se solapan con clip.\n\nelev = rast(system.file(\"raster/elev.tif\", package = \"spData\"))\nclip = rast(xmin = 0.9, xmax = 1.8, ymin = -0.45, ymax = 0.45,\n            resolution = 0.3, vals = rep(1, 9))\nelev[clip, drop = FALSE]\n## class       : SpatRaster \n## dimensions  : 2, 1, 1  (nrow, ncol, nlyr)\n## resolution  : 0.5, 0.5  (x, y)\n## extent      : 1, 1.5, -0.5, 0.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## varname     : elev \n## name        : elev \n## min value   :   18 \n## max value   :   24\n\nPara la misma operación también podemos utilizar el comando intersect() y crop().\nExtensión y origen\nCuando fusionamos o realizamos álgebra de mapas sobre rásters, su resolución, proyección, origen y/o extensión tienen que coincidir. De lo contrario, ¿cómo podríamos sumar los valores de un ráster con una resolución de 0.2 grados decimales a un segundo ráster con una resolución de 1 grado decimal? El mismo problema se plantea cuando queremos fusionar imágenes de satélite procedentes de distintos sensores con proyecciones y resoluciones diferentes. Los desajustes pueden resolverse alineando los rásters.\nEn el caso más sencillo, dos imágenes sólo difieren en su extensión. El código siguiente añade una fila y dos columnas a cada lado del ráster y establece todos los valores nuevos en NA.\n\nelev = rast(system.file(\"raster/elev.tif\", package = \"spData\"))\nelev_2 = extend(elev, c(1, 2))\n\n\n\n\n\nOriginal raster (left) and the same raster (right) extended by one row on the top and bottom and two columns on the left and right.\n\n\n\nAl realizar una operación algebraica sobre dos objetos con extensiones diferentes en R, el paquete terra devuelve un error.\n\nelev_3 = elev + elev_2\n## Error: [+] extents do not match\n\nSin embargo, podemos alinear la extensión de dos rásters con extend(). En lugar de decirle a la función cuántas filas o columnas deben añadirse (como se ha hecho antes), le permitimos que lo averigüe utilizando otro objeto raster. En este caso, ampliamos el objeto elev hasta la extensión elev_2. Los valores de las filas y columnas recién añadidas se fijan en NA.\n\nelev_4 = extend(elev, elev_2)\n\nEl origen de un raster es la esquina de la celda más cercana a las coordenadas (0, 0). La función origin() devuelve las coordenadas del origen. En el siguiente ejemplo existe una esquina de celda con coordenadas (0, 0), pero no es necesariamente el caso.\n\norigin(elev_4)\n## [1] 0 0\n\nSi dos rásters tienen orígenes diferentes, sus celdas no se solapan completamente, lo que haría imposible el álgebra de mapas. Para cambiar el origen, utilice origin().2 La próxima figura muestra el efecto de cambiar el origen de esta forma.\n\n# change the origin\norigin(elev_4) = c(0.25, 0.25)\n\n\n\n\n\nRasters with identical values but different origins.\n\n\n\nTenga en cuenta que al cambiar la resolución (apartado siguiente) también cambia con frecuencia el origen.\nAgregación y desagregación\nLos conjuntos de datos ráster también pueden diferir en cuanto a su resolución. Para igualar las resoluciones, se puede disminuir (aggregate()) o aumentar (disagg()) la resolución de un raster.3 Como ejemplo, aquí cambiamos la resolución espacial de dem (que se encuentra en el paquete spDataLarge) por un factor de 5. Además, el valor de la celda de salida debe corresponder a la media de las celdas de entrada (tenga en cuenta que también se podrían utilizar otras funciones, como median(), sum(), etc.):\n\ndem = rast(system.file(\"raster/dem.tif\", package = \"spDataLarge\"))\ndem_agg = aggregate(dem, fact = 5, fun = mean)\n\n\n\n\n\nOriginal raster (left). Aggregated raster (right).\n\n\n\nLa función disagg() aumenta la resolución de los objetos raster. Dispone de dos métodos para calcular los valores de las celdas recién creadas: el método por defecto (method = \"near\") simplemente da a todas las celdas de salida el valor de la celda de entrada y, por tanto, duplica los valores, lo que se traduce en una salida “en bloque”. El método bilineal utiliza los cuatro centros de píxel más cercanos de la imagen de entrada para calcular un promedio ponderado por la distancia. El valor de la celda de salida está representado por un cuadrado en la esquina superior izquierda.\n\ndem_disagg = disagg(dem_agg, fact = 5, method = \"bilinear\")\nidentical(dem, dem_disagg)\n## [1] FALSE\n\n\n\n\n\nThe distance-weighted average of the four closest input cells determine the output when using the bilinear method for disaggregation.\n\n\n\nLa comparación de los valores de dem y dem_disagg nos indica que no son idénticos (también puede utilizar compareGeom() o all.equal()). Sin embargo, esto no era de esperar, ya que la desagregación es una simple técnica de interpolación. Es importante tener en cuenta que la desagregación da como resultado una resolución más fina; los valores correspondientes, sin embargo, sólo son tan precisos como su fuente de menor resolución.\nRemuestreo\nLos métodos anteriores de agregación y desagregación sólo son adecuados cuando queremos cambiar la resolución de nuestro ráster mediante el factor de agregación/desagregación. Sin embargo, ¿qué hacer cuando tenemos dos o más rásters con resoluciones y orígenes diferentes? Esta es la función del remuestreo, un proceso de cálculo de valores para las nuevas ubicaciones de los píxeles. En resumen, este proceso toma los valores de nuestro ráster original y recalcula nuevos valores para un ráster de destino con resolución y origen personalizados.\n\n\n\n\nResampling of an original (input) raster into a target raster with custom resolution and origin.\n\n\n\nExisten varios métodos para estimar los valores de un ráster con diferentes resoluciones/orígenes. Los principales métodos de remuestreo son\n\nVecino más cercano: asigna el valor de la celda más cercana del ráster original a la celda del objetivo. Se trata de una técnica rápida y sencilla que suele ser adecuada para el remuestreo de rásters categóricos.\nInterpolación bilineal: asigna una media ponderada de las cuatro celdas más cercanas del raster original a la celda del raster de destino. Es el método más rápido y apropiado para rásters continuos.\nInterpolación cúbica: utiliza los valores de las 16 celdas más cercanas del ráster original para determinar el valor de la celda de salida, aplicando funciones polinómicas de tercer orden. Se utiliza para rásters continuos y da como resultado una superficie más suave en comparación con la interpolación bilineal, pero es computacionalmente más exigente.\nInterpolación spline cúbica: también utiliza los valores de las 16 celdas más cercanas del ráster original para determinar el valor de la celda de salida, pero aplica splines cúbicos (funciones polinómicas de tercer orden a trozos). Se utiliza para raster continuos.\nRemuestreo sinc con ventana de Lanczos: utiliza los valores de las 36 celdas más cercanas del raster original para determinar el valor de la celda de salida. Se utiliza para los raster continuos.\n\nLa explicación anterior pone de relieve que sólo el remuestreo de vecino más próximo es adecuado para los rásteres categóricos, mientras que todos los métodos pueden utilizarse (con diferentes resultados) para los rásteres continuos. Tenga en cuenta también que los métodos ganan en complejidad y tiempo de procesamiento de arriba a abajo.\nPara aplicar el remuestreo, el paquete terra proporciona una función resample(). Acepta un ráster de entrada (x), un ráster objetivo (y) y un método de remuestreo (method).\nNecesitamos un ráster objetivo para ver cómo funciona la función resample(). Para este ejemplo, creamos target_rast, pero a menudo se utiliza un objeto raster ya existente.\n\ntarget_rast = rast(xmin = 794650, xmax = 798250, \n                   ymin = 8931750, ymax = 8935350,\n                   resolution = 300, crs = \"EPSG:32717\")\n\nA continuación, tenemos que proporcionar nuestros dos objetos raster como los dos primeros argumentos y uno de los métodos de remuestreo descritos anteriormente.\n\ndem_resampl = resample(dem, y = target_rast, method = \"bilinear\")\n\nLa próxima figura muestra una comparación de diferentes métodos de remuestreo en el objeto dem.\n\n\n\n\nVisual comparison of the original raster and five different resampling methods.\n\n\n\nLa función resample() también tiene algunos métodos de remuestreo adicionales, como sum, min, q1, med, q3, max, average, mode y rms. Todos ellos calculan una estadística determinada basándose en los valores de todas las celdas de la cuadrícula que no son NA. Por ejemplo, sum es útil cuando cada celda raster representa una variable espacialmente extensa (por ejemplo, el número de personas). Como consecuencia del uso de sum, el ráster remuestreado debería tener el mismo número total de personas que el original.\nLa reproyección de raster es un caso especial de remuestreo cuando nuestro raster de destino tiene un CRS diferente al del raster original."
  },
  {
    "objectID": "operaciones_geometricas.html#footnotes",
    "href": "operaciones_geometricas.html#footnotes",
    "title": "Operaciones geométricas",
    "section": "Notas",
    "text": "Notas\n\n La simplificación de objetos multipoligonales puede eliminar pequeños polígonos internos, incluso si el argumento keep_shapes está ajustado a TRUE. Para evitar esto, es necesario establecer explode = TRUE. Esta opción convierte todos los mutlipolígonos en polígonos separados antes de su simplificación.↩︎\n Si los orígenes de dos conjuntos de datos ráster están sólo marginalmente separados, a veces es suficiente simplemente aumentar el argumento tolerance de terra::terraOptions().↩︎\n Aquí nos referimos a la resolución espacial. En teledetección también son importantes la resolución espectral (bandas espectrales), temporal (observaciones a lo largo del tiempo de la misma zona) y radiométrica (profundidad de color). Consulte el ejemplo tapp() de la documentación para hacerse una idea de cómo realizar la agregación temporal de rásters.↩︎"
  }
]