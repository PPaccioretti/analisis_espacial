<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Modificado de https://r.geocompx.org/">

<title>Operaciones espaciales</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="operaciones_espaciales_files/libs/clipboard/clipboard.min.js"></script>
<script src="operaciones_espaciales_files/libs/quarto-html/quarto.js"></script>
<script src="operaciones_espaciales_files/libs/quarto-html/popper.min.js"></script>
<script src="operaciones_espaciales_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="operaciones_espaciales_files/libs/quarto-html/anchor.min.js"></script>
<link href="operaciones_espaciales_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="operaciones_espaciales_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="operaciones_espaciales_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="operaciones_espaciales_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="operaciones_espaciales_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#operaciones-espaciales-sobre-datos-vectoriales" id="toc-operaciones-espaciales-sobre-datos-vectoriales" class="nav-link active" data-scroll-target="#operaciones-espaciales-sobre-datos-vectoriales">Operaciones espaciales sobre datos vectoriales</a>
  <ul class="collapse">
  <li><a href="#subdivisión-espacial" id="toc-subdivisión-espacial" class="nav-link" data-scroll-target="#subdivisión-espacial">Subdivisión espacial</a></li>
  <li><a href="#unión-espacial" id="toc-unión-espacial" class="nav-link" data-scroll-target="#unión-espacial">Unión espacial</a></li>
  <li><a href="#uniones-no-solapadas" id="toc-uniones-no-solapadas" class="nav-link" data-scroll-target="#uniones-no-solapadas">Uniones no solapadas</a></li>
  <li><a href="#agregación-espacial" id="toc-agregación-espacial" class="nav-link" data-scroll-target="#agregación-espacial">Agregación espacial</a></li>
  <li><a href="#relaciones-de-distancia" id="toc-relaciones-de-distancia" class="nav-link" data-scroll-target="#relaciones-de-distancia">Relaciones de distancia</a></li>
  </ul></li>
  <li><a href="#operaciones-espaciales-sobre-datos-ráster" id="toc-operaciones-espaciales-sobre-datos-ráster" class="nav-link" data-scroll-target="#operaciones-espaciales-sobre-datos-ráster">Operaciones espaciales sobre datos ráster</a>
  <ul class="collapse">
  <li><a href="#subdivisión-espacial-1" id="toc-subdivisión-espacial-1" class="nav-link" data-scroll-target="#subdivisión-espacial-1">Subdivisión espacial</a></li>
  <li><a href="#álgebra-de-mapas" id="toc-álgebra-de-mapas" class="nav-link" data-scroll-target="#álgebra-de-mapas">Álgebra de mapas</a></li>
  <li><a href="#operaciones-locales" id="toc-operaciones-locales" class="nav-link" data-scroll-target="#operaciones-locales">Operaciones locales</a></li>
  <li><a href="#operaciones-focales" id="toc-operaciones-focales" class="nav-link" data-scroll-target="#operaciones-focales">Operaciones focales</a></li>
  <li><a href="#operaciones-zonales" id="toc-operaciones-zonales" class="nav-link" data-scroll-target="#operaciones-zonales">Operaciones zonales</a></li>
  <li><a href="#operaciones-globales" id="toc-operaciones-globales" class="nav-link" data-scroll-target="#operaciones-globales">Operaciones globales</a></li>
  <li><a href="#fusión-de-rásters" id="toc-fusión-de-rásters" class="nav-link" data-scroll-target="#fusión-de-rásters">Fusión de rásters</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Operaciones espaciales</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Modificado de <a href="https://r.geocompx.org/" class="uri">https://r.geocompx.org/</a> </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(sf)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(terra)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(spData)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Las operaciones espaciales, incluidas las uniones espaciales entre conjuntos de datos vectoriales y las operaciones locales y focales en datos ráster, son una parte vital de la geocomputación. Los objetos espaciales pueden modificarse de múltiples maneras en función de su ubicación y forma. Muchas operaciones espaciales tienen un equivalente no espacial (atributo), por lo que conceptos como el subset y la unión de conjuntos de datos demostrados anteriormente son aplicables aquí.</p>
<p>Sin embargo, las operaciones espaciales difieren de las no espaciales en varios aspectos. Las uniones espaciales, por ejemplo, pueden realizarse de varias formas, incluida la coincidencia de entidades que se cruzan o se encuentran a una cierta distancia del conjunto de datos de destino, mientras que las uniones por atributos sólo pueden realizarse de una forma.</p>
<p>Otro aspecto único de los objetos espaciales es la distancia: todos los objetos espaciales se relacionan a través del espacio, y los cálculos de distancia se pueden utilizar para explorar la fuerza de esta relación (Sección @ref(relaciones-distancia)).</p>
<p>Las operaciones espaciales sobre objetos ráster incluyen el subset o subdivisión y la fusión de varios “mosaicos” ráster en un único objeto. El álgebra de mapas abarca una serie de operaciones que modifican los valores de las celdas ráster, con o sin referencia a los valores de las celdas circundantes. Así, se muestran operaciones de álgebra de mapas locales, focales, zonales y globales.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Es importante tener en cuenta que las operaciones espaciales que utilizan dos objetos espaciales dependen de que ambos objetos tengan el mismo sistema de coordenadas.</p>
</div>
</div>
<section id="operaciones-espaciales-sobre-datos-vectoriales" class="level2">
<h2 class="anchored" data-anchor-id="operaciones-espaciales-sobre-datos-vectoriales">Operaciones espaciales sobre datos vectoriales</h2>
<p>Esta sección proporciona una visión general de las operaciones espaciales sobre datos geográficos vectoriales <strong>sf</strong>.</p>
<section id="subdivisión-espacial" class="level3">
<h3 class="anchored" data-anchor-id="subdivisión-espacial">Subdivisión espacial</h3>
<p>El subset espacial es el proceso de tomar un objeto espacial y devolver un nuevo objeto que contenga sólo las características que se <em>relacionan</em> en el espacio con otro objeto. De forma análoga al <em>sudset de atributos</em>, pueden crearse subconjuntos de data.frames <code>sf</code> con el operador corchete (<code>[</code>) utilizando la sintaxis <code>x[y, , op = st_intersects]</code>, donde <code>x</code> es un objeto <code>sf</code> del que se obtendrá un subconjunto de filas, <code>y</code> es el <code>objeto de subconjunto</code> y <code>, op = st_intersects</code> es un argumento opcional que especifica la relación topológica (también conocida como predicado binario) utilizada para realizar el subconjunto.</p>
<p>La relación topológica por defecto utilizada cuando no se proporciona un argumento <code>op</code> es <code>st_intersects()</code>: el comando <code>x[y, ]</code> es idéntico a <code>x[y, , op = st_intersects]</code> mostrado anteriormente pero no a <code>x[y, , op = st_disjoint]</code> (el significado de estas y otras relaciones topológicas se describe en la siguiente sección).</p>
<p>Para demostrar el subset espacial, utilizaremos los conjuntos de datos <code>nz</code> y <code>nz_height</code> del paquete <strong>spData</strong>, que contienen datos geográficos sobre las 16 regiones principales y los 101 puntos más altos de Nueva Zelanda, respectivamente (Figura @ref(fig:nz-subset)), en un sistema de coordenadas proyectado. El siguiente fragmento de código crea un objeto que representa Canterbury y, a continuación, utiliza el subset espacial para devolver todos los puntos altos de la región:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>canterbury <span class="ot">=</span> nz <span class="sc">|&gt;</span> <span class="fu">filter</span>(Name <span class="sc">==</span> <span class="st">"Canterbury"</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>canterbury_height <span class="ot">=</span> nz_height[canterbury, ]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="operaciones_espaciales_files/figure-html/nz-subset-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Illustration of spatial subsetting with red triangles representing 101 high points in New Zealand, clustered near the central Canterbuy region (left). The points in Canterbury were created with the <code>[</code> subsetting operator (highlighted in gray, right).</figcaption>
</figure>
</div>
</div>
</div>
<p>Al igual que el subset de atributos, el comando <code>x[y, ]</code> (equivalente a <code>nz_height[canterbury, ]</code>) selecciona características de un objeto <em>objetivo</em> <code>x</code> utilizando el contenido de un objeto <em>fuente</em> <code>y</code>. Sin embargo, en lugar de que <code>y</code> sea un vector de clase <code>lógica</code> o <code>entera</code>, para el subset espacial tanto <code>x</code> como <code>y</code> deben ser objetos geográficos, en este caso <code>sf</code>.</p>
<p>Se pueden utilizar varias <em>relaciones topológicas</em> que determinan el tipo de relación espacial pueden ser: <em>toques</em>, <em>cruces</em> o <em>dentro de</em>. El parámetro por defecto <code>st_intersects</code> es una relación topológica tipo ‘catch all’ que devolverá características en el objetivo que <em>toquen</em>, <em>crucen</em> o estén <em>dentro</em> del objeto fuente. Como se ha indicado anteriormente, se pueden especificar operadores espaciales alternativos con el argumento <code>op =</code>, como se demuestra en el siguiente comando que devuelve lo contrario de <code>st_intersects()</code>, puntos que no se intersecan con Canterbury:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>nz_height[canterbury, , op <span class="ot">=</span> st_disjoint]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Observe que el argumento vacío — denotado con <code>, ,</code> — en el trozo de código anterior se incluye para resaltar <code>op</code>, el tercer argumento en <code>[</code> para objetos <code>sf</code>. Se puede utilizar para cambiar la operación de subset de muchas maneras. <code>nz_height[canterbury, 2, op = st_disjoint]</code>, por ejemplo, devuelve las mismas filas pero sólo incluye la segunda columna de atributos (véase <code>sf:::`[.sf`</code> y el <code>?sf</code> para más detalles).</p>
</div>
</div>
</section>
<section id="unión-espacial" class="level3">
<h3 class="anchored" data-anchor-id="unión-espacial">Unión espacial</h3>
<p>La unión de dos conjuntos de datos no espaciales se basa en una variable “clave” compartida o <em>key</em>. La unión de datos espaciales aplica el mismo concepto, pero se basa en las relaciones espaciales. Al igual que con los atributos, la unión añade nuevas columnas al objeto de destino (el argumento <code>x</code> en las funciones de unión), a partir de un objeto de origen (<code>y</code>).</p>
<p>El proceso se ilustra con el siguiente ejemplo: imagine que tiene diez puntos distribuidos aleatoriamente por la superficie de la Tierra y pregunta, para los puntos que están en tierra, ¿en qué países se encuentran?</p>
<p>El punto de partida es crear puntos dispersos aleatoriamente por la superficie terrestre:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">2018</span>) <span class="co"># set seed for reproducibility</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>(<span class="at">bb =</span> <span class="fu">st_bbox</span>(world)) <span class="co"># the world's bounds</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      xmin       ymin       xmax       ymax 
-180.00000  -89.90000  179.99999   83.64513 </code></pre>
</div>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>random_df <span class="ot">=</span> <span class="fu">data.frame</span>(</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">x =</span> <span class="fu">runif</span>(<span class="at">n =</span> <span class="dv">10</span>, <span class="at">min =</span> bb[<span class="dv">1</span>], <span class="at">max =</span> bb[<span class="dv">3</span>]),</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">y =</span> <span class="fu">runif</span>(<span class="at">n =</span> <span class="dv">10</span>, <span class="at">min =</span> bb[<span class="dv">2</span>], <span class="at">max =</span> bb[<span class="dv">4</span>])</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>random_points <span class="ot">=</span> random_df <span class="sc">|&gt;</span> </span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">st_as_sf</span>(<span class="at">coords =</span> <span class="fu">c</span>(<span class="st">"x"</span>, <span class="st">"y"</span>), <span class="at">crs =</span> <span class="st">"EPSG:4326"</span>) <span class="co"># set coordinates and CRS</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El escenario ilustrado abajo muestra que el objeto <code>random_points</code> (arriba a la izquierda) carece de datos de atributos, mientras que el <code>world</code> (arriba a la derecha) tiene atributos, incluidos los nombres de los países mostrados para una muestra de países en la leyenda. Las uniones espaciales se implementan con <code>st_join()</code>, como se ilustra en el siguiente fragmento de código. El resultado es el objeto <code>random_joined</code> que se ilustra abajo a la izquierda.</p>
<p><img src="https://r.geocompx.org/04-spatial-operations_files/figure-html/spatial-join-1.png" class="img-fluid"></p>
<p>Antes de crear el conjunto de datos unido, utilizamos el subconjunto espacial para crear <code>world_random</code>, que contiene sólo países que contienen puntos aleatorios, para verificar que el número de nombres de países devueltos en el conjunto de datos unido debe ser cuatro.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>world_random <span class="ot">=</span> world[random_points, ]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fu">nrow</span>(world_random)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 4</code></pre>
</div>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>random_joined <span class="ot">=</span> <span class="fu">st_join</span>(random_points, world[<span class="st">"name_long"</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Por defecto, <code>st_join()</code> realiza una unión a la izquierda, lo que significa que el resultado es un objeto que contiene todas las filas de <code>x</code> incluyendo las filas que no coinciden con <code>y</code>, pero también puede realizar uniones internas estableciendo el argumento <code>left = FALSE</code>. Al igual que el subset espacial, el operador topológico por defecto utilizado por <code>st_join()</code> es <code>st_intersects()</code>, que puede cambiarse estableciendo el argumento <code>join</code> (véase <code>?st_join</code> para más detalles). El ejemplo anterior muestra la adición de una columna de una capa de polígonos a una capa de puntos, pero el método funciona independientemente del tipo de geometría. En tales casos, por ejemplo cuando <code>x</code> contiene polígonos, cada uno de los cuales coincide con múltiples objetos en <code>y</code>, las uniones espaciales darán lugar a características duplicadas al crear una nueva fila por cada coincidencia en <code>y</code>.</p>
</section>
<section id="uniones-no-solapadas" class="level3">
<h3 class="anchored" data-anchor-id="uniones-no-solapadas">Uniones no solapadas</h3>
<p>A veces, dos conjuntos de datos geográficos no se tocan, pero mantienen una estrecha relación geográfica. Los conjuntos de datos <code>cycle_hire</code> y <code>cycle_hire_osm</code>, ya adjuntos en el paquete <strong>spData</strong>, constituyen un buen ejemplo. Su representación gráfica muestra que a menudo están estrechamente relacionados pero no se tocan, como se muestra abajo:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">st_geometry</span>(cycle_hire), <span class="at">col =</span> <span class="st">"blue"</span>)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">st_geometry</span>(cycle_hire_osm), <span class="at">add =</span> <span class="cn">TRUE</span>, <span class="at">pch =</span> <span class="dv">3</span>, <span class="at">col =</span> <span class="st">"red"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Podemos comprobar si algún punto coincide con <code>st_intersects()</code> como se muestra a continuación:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">any</span>(<span class="fu">st_touches</span>(cycle_hire, cycle_hire_osm, <span class="at">sparse =</span> <span class="cn">FALSE</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] FALSE</code></pre>
</div>
</div>
<p>Imaginemos que necesitamos unir la variable <code>capacity</code> de <code>cycle_hire_osm</code> a los datos oficiales <code>target</code> contenidos en <code>cycle_hire</code>. En este caso se necesita una unión no solapada. El método más sencillo es utilizar el predicado binario <code>st_is_within_distance()</code>, como se muestra a continuación utilizando una distancia umbral de 20 m. Se puede establecer la distancia umbral en unidades métricas también para datos no proyectados (por ejemplo, lon/lat CRSs como WGS84), si el motor de geometría esférica (s2) está habilitado, como lo está en <strong>sf</strong> por defecto.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>sel <span class="ot">=</span> <span class="fu">st_is_within_distance</span>(cycle_hire, cycle_hire_osm, </span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>                            <span class="at">dist =</span> units<span class="sc">::</span><span class="fu">set_units</span>(<span class="dv">20</span>, <span class="st">"m"</span>))</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(<span class="fu">lengths</span>(sel) <span class="sc">&gt;</span> <span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   Mode   FALSE    TRUE 
logical     304     438 </code></pre>
</div>
</div>
<p>Esto muestra que hay 438 puntos en el objeto de destino <code>cycle_hire</code> dentro de la distancia umbral de <code>cycle_hire_osm</code>. ¿Cómo recuperar los <em>valores</em> asociados a los respectivos puntos de <code>cycle_hire_osm</code>? La solución es de nuevo con <code>st_join()</code>, pero añadiendo el argumento <code>dist</code> (fijado en 20 m más abajo):</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>z <span class="ot">=</span> <span class="fu">st_join</span>(cycle_hire, cycle_hire_osm, st_is_within_distance, </span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>            <span class="at">dist =</span> units<span class="sc">::</span><span class="fu">set_units</span>(<span class="dv">20</span>, <span class="st">"m"</span>))</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="fu">nrow</span>(cycle_hire)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 742</code></pre>
</div>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">nrow</span>(z)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 762</code></pre>
</div>
</div>
<p>Observe que el número de filas del resultado unido es mayor que el objetivo. Esto se debe a que algunas estaciones de alquiler de bicicletas en <code>cycle_hire</code> tienen múltiples coincidencias en <code>cycle_hire_osm</code>. Para agregar los valores de los puntos solapados y devolver la media, podemos utilizar los métodos de agregación aprendidos ates, dando como resultado un objeto con el mismo número de filas que el objetivo:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>z <span class="ot">=</span> z <span class="sc">|&gt;</span> </span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(id) <span class="sc">|&gt;</span> </span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarize</span>(<span class="at">capacity =</span> <span class="fu">mean</span>(capacity))</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="fu">nrow</span>(z) <span class="sc">==</span> <span class="fu">nrow</span>(cycle_hire)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] TRUE</code></pre>
</div>
</div>
<p>La capacidad de las estaciones cercanas puede verificarse comparando un gráfico de la capacidad de los datos de la fuente <code>cycle_hire_osm</code> con los resultados de este nuevo objeto (gráficos no mostrados):</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(cycle_hire_osm[<span class="st">"capacity"</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="operaciones_espaciales_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid" width="672"></p>
</div>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(z[<span class="st">"capacity"</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="operaciones_espaciales_files/figure-html/unnamed-chunk-3-2.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>El resultado de esta unión ha utilizado una operación espacial para cambiar los datos de atributos asociados a sf; la geometría asociada a cada característica ha permanecido inalterada.</p>
</section>
<section id="agregación-espacial" class="level3">
<h3 class="anchored" data-anchor-id="agregación-espacial">Agregación espacial</h3>
<p>Al igual que la agregación de datos de atributos, la agregación de datos espaciales <em>condensa</em> los datos: las salidas agregadas tienen menos filas que las entradas no agregadas. Las funciones de <em>agregación estadística</em>, como la media o la suma, resumen múltiples valores de una variable, y devuelven un único valor por <em>variable de agrupación</em>. Ya se demostró cómo <code>aggregate()</code> y <code>group_by() |&gt; summarize()</code> condensan datos basados en variables de atributo, esta sección muestra cómo funcionan las mismas funciones con objetos espaciales.</p>
<p>Volviendo al ejemplo de Nueva Zelanda, imagine que desea averiguar la altura media de los puntos altos de cada región: es la geometría de la fuente (<code>y</code> o <code>nz</code> en este caso) la que define cómo se agrupan los valores en el objeto de destino (<code>x</code> o <code>nz_height</code>). Esto se puede hacer en una sola línea de código con el método <code>aggregate()</code> de R base:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>nz_agg <span class="ot">=</span> <span class="fu">aggregate</span>(<span class="at">x =</span> nz_height, <span class="at">by =</span> nz, <span class="at">FUN =</span> mean)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El resultado del comando anterior es un objeto <code>sf</code> con la misma geometría que el objeto de agregación (espacial) (<code>nz</code>), lo que puede comprobar con el comando <code>identical(st_geometry(nz), st_geometry(nz_agg))</code>. El resultado de la operación anterior se ilustra en la figura <span class="citation" data-cites="ref">@ref</span>(fig:spatial-aggregation), que muestra el valor medio de las características en <code>nz_height</code> dentro de cada una de las 16 regiones de Nueva Zelanda. El mismo resultado también puede generarse canalizando la salida de <code>st_join()</code> a las funciones <code>group_by()</code> y <code>summarize()</code> de la siguiente forma:</p>
<div class="cell" data-fig.asp="1">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="operaciones_espaciales_files/figure-html/spatial-aggregation-1.png" class="img-fluid figure-img" style="width:50.0%"></p>
<figcaption class="figure-caption">Average height of the top 101 high points across the regions of New Zealand.</figcaption>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>nz_agg2 <span class="ot">=</span> <span class="fu">st_join</span>(<span class="at">x =</span> nz, <span class="at">y =</span> nz_height) <span class="sc">|&gt;</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(Name) <span class="sc">|&gt;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarize</span>(<span class="at">elevation =</span> <span class="fu">mean</span>(elevation, <span class="at">na.rm =</span> <span class="cn">TRUE</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Los objetos <code>nz_agg</code> resultantes tienen la misma geometría que el objeto agregador <code>nz</code> pero con una nueva columna que resume los valores de <code>x</code> en cada región utilizando la función <code>mean()</code>. Se pueden utilizar otras funciones en lugar de <code>mean()</code>, incluyendo <code>median()</code>, <code>sd()</code> y otras funciones que devuelven un único valor por grupo.</p>
</section>
<section id="relaciones-de-distancia" class="level3">
<h3 class="anchored" data-anchor-id="relaciones-de-distancia">Relaciones de distancia</h3>
<p>Mientras que las relaciones topológicas son binarias (una característica se cruza con otra o no), las relaciones de distancia son continuas. La distancia entre dos objetos se calcula con la función <code>st_distance()</code>. Esto se ilustra en el siguiente fragmento de código, que encuentra la distancia entre el punto más alto de Nueva Zelanda y el centroide geográfico de la región de Canterbury:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>nz_highest <span class="ot">=</span> nz_height <span class="sc">|&gt;</span> <span class="fu">slice_max</span>(<span class="at">n =</span> <span class="dv">1</span>, <span class="at">order_by =</span> elevation)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>canterbury_centroid <span class="ot">=</span> <span class="fu">st_centroid</span>(canterbury)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="fu">st_distance</span>(nz_highest, canterbury_centroid)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Units: [m]
       [,1]
[1,] 115540</code></pre>
</div>
</div>
<p>Hay dos cosas potencialmente sorprendentes en el resultado:</p>
<ul>
<li>Tiene “unidades”, lo que nos indica que la distancia es de 100.000 metros, no de 100.000 pulgadas ni de ninguna otra medida de distancia.</li>
<li>Se devuelve como una matriz, aunque el resultado sólo contenga un valor.</li>
</ul>
<p>Esta segunda característica indica otra característica útil de <code>st_distance()</code>, su capacidad para devolver <em>matrices de distancia</em> entre todas las combinaciones de características en los objetos <code>x</code> e <code>y</code>. Esto se ilustra en el siguiente comando, que encuentra las distancias entre las tres primeras características de <code>nz_height</code> y las regiones de Otago y Canterbury de Nueva Zelanda representadas por el objeto <code>co</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>co <span class="ot">=</span> <span class="fu">filter</span>(nz, <span class="fu">grepl</span>(<span class="st">"Canter|Otag"</span>, Name))</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="fu">st_distance</span>(nz_height[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, ], co)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Units: [m]
          [,1]     [,2]
[1,] 123537.16 15497.72
[2,]  94282.77     0.00
[3,]  93018.56     0.00</code></pre>
</div>
</div>
<p>Observe que la distancia entre la segunda y tercera características de <code>nz_height</code> y la segunda característica de <code>co</code> es cero. Esto demuestra el hecho de que las distancias entre puntos y polígonos se refieren a la distancia a <em>cualquier parte del polígono</em>: Los puntos segundo y tercero de <code>nz_height</code> están <em>en</em> Otago, lo que puede comprobarse trazándolos:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">st_geometry</span>(co)[<span class="dv">2</span>])</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">st_geometry</span>(nz_height)[<span class="dv">2</span><span class="sc">:</span><span class="dv">3</span>], <span class="at">add =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="operaciones_espaciales_files/figure-html/04-spatial-operations-33-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
</section>
<section id="operaciones-espaciales-sobre-datos-ráster" class="level2">
<h2 class="anchored" data-anchor-id="operaciones-espaciales-sobre-datos-ráster">Operaciones espaciales sobre datos ráster</h2>
<p>Esta sección demuestra operaciones ráster más avanzadas y explícitamente espaciales con los objetos <code>elev</code> y <code>grain</code> del paquete <strong>spData</strong>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>elev <span class="ot">=</span> <span class="fu">rast</span>(<span class="fu">system.file</span>(<span class="st">"raster/elev.tif"</span>, <span class="at">package =</span> <span class="st">"spData"</span>))</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>grain <span class="ot">=</span> <span class="fu">rast</span>(<span class="fu">system.file</span>(<span class="st">"raster/grain.tif"</span>, <span class="at">package =</span> <span class="st">"spData"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="subdivisión-espacial-1" class="level3">
<h3 class="anchored" data-anchor-id="subdivisión-espacial-1">Subdivisión espacial</h3>
<p>Ya se vio cómo recuperar valores asociados con IDs de celdas específicas o combinaciones de filas y columnas. Los objetos ráster también pueden subdividirse por ubicación (coordenadas) y con otros objetos espaciales. Para utilizar coordenadas para realizar el subset, se pueden “traducir” las coordenadas a un ID de celda con la función <strong>terra</strong> <code>cellFromXY()</code>. Una alternativa es utilizar <code>terra::extract()</code> para extraer valores. Ambos métodos se demuestran a continuación para encontrar el valor de la celda que cubre un punto situado en las coordenadas (0.1, 0.1).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>id <span class="ot">=</span> <span class="fu">cellFromXY</span>(elev, <span class="at">xy =</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="fl">0.1</span>, <span class="fl">0.1</span>), <span class="at">ncol =</span> <span class="dv">2</span>))</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>elev[id]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="kable-table">
<table class="table table-sm table-striped small">
<thead>
<tr class="header">
<th style="text-align: right;">elev</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">16</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co"># the same as</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>terra<span class="sc">::</span><span class="fu">extract</span>(elev, <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="fl">0.1</span>, <span class="fl">0.1</span>), <span class="at">ncol =</span> <span class="dv">2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="kable-table">
<table class="table table-sm table-striped small">
<thead>
<tr class="header">
<th style="text-align: right;">elev</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">16</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<p>Los objetos ráster también se pueden subdividir con otro objeto ráster, como se demuestra en el fragmento de código siguiente:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>clip <span class="ot">=</span> <span class="fu">rast</span>(<span class="at">xmin =</span> <span class="fl">0.9</span>, <span class="at">xmax =</span> <span class="fl">1.8</span>, <span class="at">ymin =</span> <span class="sc">-</span><span class="fl">0.45</span>, <span class="at">ymax =</span> <span class="fl">0.45</span>,</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>            <span class="at">resolution =</span> <span class="fl">0.3</span>, <span class="at">vals =</span> <span class="fu">rep</span>(<span class="dv">1</span>, <span class="dv">9</span>))</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>elev[clip]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="kable-table">
<table class="table table-sm table-striped small">
<thead>
<tr class="header">
<th style="text-align: right;">elev</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">18</td>
</tr>
<tr class="even">
<td style="text-align: right;">24</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co"># we can also use extract</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="co"># terra::extract(elev, ext(clip))</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Se trata de recuperar los valores del primer objeto raster (en este caso, <code>elev</code>) que se encuentran dentro de la extensión de un segundo raster.</p>
<p>El ejemplo anterior devolvía los valores de celdas específicas, pero en muchos casos se necesitan salidas espaciales. Esto puede hacerse estableciendo el argumento <code>drop</code> del operador <code>[</code> en <code>FALSE</code>. El siguiente código devuelve las dos primeras celdas de <code>elev</code>, es decir, las dos primeras celdas de la fila superior, como un objeto raster:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>elev[<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>, drop <span class="ot">=</span> <span class="cn">FALSE</span>]    <span class="co"># spatial subsetting with cell IDs</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>class       : SpatRaster 
dimensions  : 1, 2, 1  (nrow, ncol, nlyr)
resolution  : 0.5, 0.5  (x, y)
extent      : -1.5, -0.5, 1, 1.5  (xmin, xmax, ymin, ymax)
coord. ref. : lon/lat WGS 84 (EPSG:4326) 
source(s)   : memory
name        : elev 
min value   :    1 
max value   :    2 </code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<p><img src="operaciones_espaciales_files/figure-html/04-spatial-operations-37-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Otro caso de uso común del subset espacial es cuando un ráster con valores <code>lógicos</code> (o <code>NA</code>) se utiliza para enmascarar otro ráster con la misma extensión y resolución. En este caso, pueden utilizarse las funciones <code>[</code> y <code>mask()</code> (resultados no mostrados):</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co"># create raster mask</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>rmask <span class="ot">=</span> elev</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="fu">values</span>(rmask) <span class="ot">=</span> <span class="fu">sample</span>(<span class="fu">c</span>(<span class="cn">NA</span>, <span class="cn">TRUE</span>), <span class="dv">36</span>, <span class="at">replace =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>En el fragmento de código anterior, hemos creado un objeto máscara llamado <code>rmask</code> con valores asignados aleatoriamente a <code>NA</code> y <code>TRUE</code>. A continuación, queremos mantener los valores de <code>elev</code> que son <code>TRUE</code> en <code>rmask</code>. En otras palabras, queremos enmascarar <code>elev</code> con <code>rmask</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co"># spatial subsetting</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>elev[rmask, drop <span class="ot">=</span> <span class="cn">FALSE</span>]           <span class="co"># with [ operator</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="fu">mask</span>(elev, rmask)                   <span class="co"># with mask()</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El enfoque anterior también se puede utilizar para sustituir algunos valores (por ejemplo, los que se espera que sean erróneos) por NA.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>elev[elev <span class="sc">&lt;</span> <span class="dv">20</span>] <span class="ot">=</span> <span class="cn">NA</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Estas operaciones son, de hecho, operaciones locales booleanas, ya que comparamos celda por celda dos rásters. En la siguiente subsección se analizan con más detalle estas operaciones y otras relacionadas.</p>
</section>
<section id="álgebra-de-mapas" class="level3">
<h3 class="anchored" data-anchor-id="álgebra-de-mapas">Álgebra de mapas</h3>
<p>El término ‘álgebra de mapas’ se acuñó a finales de la década de 1970 para describir un “conjunto de convenciones, capacidades y técnicas” para el análisis de datos geográficos ráster <em>y</em> (aunque con menos prominencia) vectoriales. En este contexto, definimos el álgebra de mapas de forma más restringida, como operaciones que modifican o resumen valores de celdas ráster, con referencia a celdas circundantes, zonas o funciones estadísticas que se aplican a cada celda.</p>
<p>Las operaciones de álgebra de mapas suelen ser rápidas, porque los conjuntos de datos ráster sólo almacenan implícitamente coordenadas. La ubicación de las celdas en los conjuntos de datos ráster puede calcularse utilizando su posición matricial y la resolución y origen del conjunto de datos (almacenados en la cabecera). Para el procesamiento, sin embargo, la posición geográfica de una celda apenas es relevante, siempre y cuando nos aseguremos de que la posición de la celda sigue siendo la misma después del procesamiento. Además, si dos o más conjuntos de datos ráster comparten la misma extensión, proyección y resolución, se podrían tratar como matrices.</p>
<p>Así funciona el álgebra de mapas con el paquete <strong>terra</strong>. En primer lugar, se consultan las cabeceras de los conjuntos de datos ráster y se comprueba que los conjuntos de datos sean compatibles. En segundo lugar, el álgebra de mapas mantiene la llamada correspondencia de localización uno a uno, lo que significa que las celdas no pueden moverse. Esto difiere del álgebra matricial, en la que los valores cambian de posición, por ejemplo al multiplicar o dividir matrices.</p>
<p>El álgebra de mapas divide las operaciones ráster en cuatro subclases:</p>
<ol type="1">
<li><em>Operaciones locales o por celda</em></li>
<li><em>Operaciones focales</em> o de vecindad. Lo más frecuente es que el valor de la celda de salida sea el resultado de un bloque de celdas de entrada de 3 x 3</li>
<li><em>Las operaciones zonales</em> son similares a las operaciones focales, pero la cuadrícula de píxeles circundante sobre la que se calculan los nuevos valores puede tener tamaños y formas irregulares</li>
<li><em>Operaciones globales</em> o per-raster. Esto significa que la celda de salida puede derivar su valor de uno o varios rásters completos.</li>
</ol>
</section>
<section id="operaciones-locales" class="level3">
<h3 class="anchored" data-anchor-id="operaciones-locales">Operaciones locales</h3>
<p>Las operaciones locales comprenden todas las operaciones celda por celda en una o varias capas. El álgebra ráster es un caso de uso clásico de las operaciones locales, que incluye la suma o resta de valores de un ráster, el cuadrado y la multiplicación de rásters. El álgebra raster también permite realizar operaciones lógicas, como encontrar todas las celdas que superen un valor determinado. El paquete <strong>terra</strong> admite todas estas operaciones y más, como se muestra a continuación:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>elev <span class="sc">+</span> elev</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>elev<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="fu">log</span>(elev)</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>elev <span class="sc">&gt;</span> <span class="dv">5</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Otro buen ejemplo de operaciones locales es la clasificación de intervalos de valores numéricos en grupos, como la agrupación de un modelo digital de elevación en elevaciones bajas (clase 1), medias (clase 2) y altas (clase 3). Para utilizar el comando <code>classify()</code>, necesitamos primero construir una matriz de reclasificación, donde la primera columna corresponde al extremo inferior y la segunda columna al extremo superior de la clase. La tercera columna representa el nuevo valor para los rangos especificados en las columnas uno y dos.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>rcl <span class="ot">=</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">12</span>, <span class="dv">1</span>, <span class="dv">12</span>, <span class="dv">24</span>, <span class="dv">2</span>, <span class="dv">24</span>, <span class="dv">36</span>, <span class="dv">3</span>), <span class="at">ncol =</span> <span class="dv">3</span>, <span class="at">byrow =</span> <span class="cn">TRUE</span>)</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>rcl</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2] [,3]
[1,]    0   12    1
[2,]   12   24    2
[3,]   24   36    3</code></pre>
</div>
</div>
<p>Aquí, los valores ráster en los rangos 0–12, 12–24 y 24–36 se <em>reclasifican</em> para tomar los valores 1, 2 y 3, respectivamente.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>recl <span class="ot">=</span> <span class="fu">classify</span>(elev, <span class="at">rcl =</span> rcl)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La función <code>classify()</code> también puede utilizarse cuando queremos reducir el número de clases en nuestros rásters categóricos.</p>
<p>Además de los operadores aritméticos, también se pueden utilizar las funciones <code>app()</code>, <code>tapp()</code> y <code>lapp()</code>. Son más eficientes, por lo que son preferibles en presencia de grandes conjuntos de datos ráster. Además, permiten guardar directamente un archivo de salida. La función <code>app()</code> aplica una función a cada celda de un raster y se utiliza para resumir (por ejemplo, calculando la suma) los valores de múltiples capas en una sola capa. La función <code>tapp()</code> es una extensión de <code>app()</code> que nos permite seleccionar un subconjunto de capas (véase el argumento <code>index</code>) para las que queremos realizar una determinada operación. Por último, la función <code>lapp()</code> permite aplicar una función a cada celda utilizando las capas como argumentos – a continuación se presenta una aplicación de <code>lapp()</code>.</p>
<p>El cálculo del índice de vegetación de diferencia normalizada (NDVI) es una conocida operación de raster local (píxel a píxel). Devuelve un raster con valores entre -1 y 1; los valores positivos indican la presencia de plantas vivas (en su mayoría &gt; 0.2). El NDVI se calcula a partir de las bandas roja e infrarroja cercana (NIR) de imágenes satelitales.</p>
<p><span class="math display">\[
\begin{split}
NDVI&amp;= \frac{\text{NIR} - \text{Red}}{\text{NIR} + \text{Red}}\\
\end{split}
\]</span></p>
<p>Calculemos el NDVI para el archivo de satélite multiespectral del Parque Nacional de Zion.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>multi_raster_file <span class="ot">=</span> <span class="fu">system.file</span>(<span class="st">"raster/landsat.tif"</span>, <span class="at">package =</span> <span class="st">"spDataLarge"</span>)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>multi_rast <span class="ot">=</span> <span class="fu">rast</span>(multi_raster_file)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El objeto raster tiene cuatro bandas de satélite: azul, verde, rojo e infrarrojo cercano (NIR). Nuestro siguiente paso será implementar la fórmula NDVI en una función de R:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>ndvi_fun <span class="ot">=</span> <span class="cf">function</span>(nir, red){</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>  (nir <span class="sc">-</span> red) <span class="sc">/</span> (nir <span class="sc">+</span> red)</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Esta función acepta dos argumentos numéricos, <code>nir</code> y <code>red</code>, y devuelve un vector numérico con valores NDVI. Puede utilizarse como argumento <code>fun</code> de <code>lapp()</code>. Sólo tenemos que recordar que nuestra función sólo necesita dos bandas (no cuatro de la trama original), y tienen que estar en el orden NIR, rojo. Por eso, antes de hacer los cálculos, se hace un subconjunto del raster de entrada con <code>multi_rast[[c(4, 3)]]</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>ndvi_rast <span class="ot">=</span> <span class="fu">lapp</span>(multi_rast[[<span class="fu">c</span>(<span class="dv">4</span>, <span class="dv">3</span>)]], <span class="at">fun =</span> ndvi_fun)</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(ndvi_rast)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="operaciones_espaciales_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>La cartografía predictiva es otra aplicación interesante de las operaciones raster locales. La variable de respuesta corresponde a puntos medidos u observados en el espacio, por ejemplo, la riqueza de especies, la presencia de corrimientos de tierras, la enfermedad de los árboles o el rendimiento de los cultivos. Por consiguiente, podemos recuperar fácilmente variables predictoras espaciales o aéreas a partir de diversos rásters (elevación, pH, precipitaciones, temperatura, cubierta vegetal, clase de suelo, etc.). A continuación, modelizamos nuestra respuesta en función de nuestros predictores mediante <code>lm()</code>, <code>glm()</code>, <code>gam()</code> o una técnica de aprendizaje automático. Por tanto, las predicciones espaciales sobre objetos ráster pueden realizarse aplicando coeficientes estimados a los valores ráster predictores y sumando los valores ráster de salida.</p>
</section>
<section id="operaciones-focales" class="level3">
<h3 class="anchored" data-anchor-id="operaciones-focales">Operaciones focales</h3>
<p>Mientras que las funciones locales operan sobre una celda, aunque posiblemente de varias capas, las operaciones <strong>focales</strong> tienen en cuenta una celda central (focal) y sus vecinas. El vecindario (también denominado núcleo, filtro o ventana móvil) considerado suele tener un tamaño de 3 por 3 celdas (es decir, la celda central y sus ocho vecinas circundantes), pero puede adoptar cualquier otra forma (no necesariamente rectangular) definida por el usuario. Una operación focal aplica una función de agregación a todas las celdas dentro del vecindario especificado, utiliza el resultado correspondiente como nuevo valor para la celda central y pasa a la siguiente celda central. Otros nombres para esta operación son filtrado espacial y convolución.</p>
<p><img src="https://r.geocompx.org/figures/04_focal_example.png" class="img-fluid"></p>
<p>En R, podemos utilizar la función <code>focal()</code> para realizar el filtrado espacial. Definimos la forma de la ventana móvil con una “matriz” cuyos valores corresponden a los pesos (véase el parámetro “w” en el fragmento de código siguiente). En segundo lugar, el parámetro <code>fun</code> nos permite especificar la función que deseamos aplicar a este vecindario. Aquí, elegimos el mínimo, pero cualquier otra función de resumen, incluyendo <code>sum()</code>, <code>mean()</code>, o <code>var()</code> se puede utilizar.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>r_focal <span class="ot">=</span> <span class="fu">focal</span>(elev, <span class="at">w =</span> <span class="fu">matrix</span>(<span class="dv">1</span>, <span class="at">nrow =</span> <span class="dv">3</span>, <span class="at">ncol =</span> <span class="dv">3</span>), <span class="at">fun =</span> min)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Esta función también acepta argumentos adicionales, por ejemplo, si debe eliminar los NA en el proceso (<code>na.rm = TRUE</code>) o no (<code>na.rm = FALSE</code>).</p>
</section>
<section id="operaciones-zonales" class="level3">
<h3 class="anchored" data-anchor-id="operaciones-zonales">Operaciones zonales</h3>
<p>Al igual que las operaciones focales, las operaciones <em>zonales</em> aplican una función de agregación a múltiples celdas de trama. Sin embargo, un segundo ráster, normalmente con valores categóricos, define los <em>filtros zonales</em> (o “zonas”), a diferencia de una ventana de vecindad predefinida en el caso de la operación focal presentada en la sección anterior. Por consiguiente, las celdas del ráster que definen el filtro zonal no tienen por qué ser necesariamente vecinas. Nuestro ráster de tamaño de grano es un buen ejemplo: los diferentes tamaños de grano están repartidos irregularmente por todo el ráster. Por último, el resultado de una operación zonal es una tabla resumen agrupada por zonas, razón por la cual esta operación también se conoce como <em>estadística zonal</em> en el mundo SIG. Esto contrasta con las operaciones focales que devuelven un objeto raster.</p>
<p>El siguiente fragmento de código utiliza la función <code>zonal()</code> para calcular la elevación media asociada a cada clase de tamaño de grano, por ejemplo.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>z <span class="ot">=</span> <span class="fu">zonal</span>(elev, grain, <span class="at">fun =</span> <span class="st">"mean"</span>)</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>z</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="kable-table">
<table class="table table-sm table-striped small">
<thead>
<tr class="header">
<th style="text-align: left;">grain</th>
<th style="text-align: right;">elev</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">clay</td>
<td style="text-align: right;">14.80000</td>
</tr>
<tr class="even">
<td style="text-align: left;">silt</td>
<td style="text-align: right;">21.15385</td>
</tr>
<tr class="odd">
<td style="text-align: left;">sand</td>
<td style="text-align: right;">18.69231</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<p>Nota: también es posible obtener un raster con estadísticas calculadas para cada zona estableciendo el argumento <code>as.raster</code> a <code>TRUE</code>.</p>
</section>
<section id="operaciones-globales" class="level3">
<h3 class="anchored" data-anchor-id="operaciones-globales">Operaciones globales</h3>
<p>Las operaciones globales son un caso especial de las operaciones zonales, en las que todo el conjunto de datos ráster representa una única zona. Las operaciones globales más comunes son las estadísticas descriptivas para todo el conjunto de datos ráster.</p>
</section>
<section id="fusión-de-rásters" class="level3">
<h3 class="anchored" data-anchor-id="fusión-de-rásters">Fusión de rásters</h3>
<p>Supongamos que queremos calcular el NDVI, y además queremos calcular atributos del terreno a partir de datos de elevación para observaciones dentro de un área de estudio. Estos cálculos se basan en información obtenida por teledetección. Las imágenes correspondientes suelen dividirse en escenas que cubren una extensión espacial específica y, con frecuencia, un área de estudio abarca más de una escena. Entonces, tendríamos que fusionar las escenas cubiertas por nuestra zona de estudio. En el caso más sencillo, basta con fusionar las escenas, es decir, ponerlas una al lado de la otra. Esto es posible, por ejemplo, con datos digitales de elevación (SRTM, ASTER). En el siguiente fragmento de código descargamos primero los datos de elevación SRTM de Austria y Suiza (para los códigos de país, véase la función <strong>geodata</strong> <code>country_codes()</code>). En un segundo paso, fusionamos los dos rásters en uno.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>aut <span class="ot">=</span> geodata<span class="sc">::</span><span class="fu">elevation_30s</span>(<span class="at">country =</span> <span class="st">"AUT"</span>, <span class="at">path =</span> <span class="fu">tempdir</span>())</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>ch <span class="ot">=</span> geodata<span class="sc">::</span><span class="fu">elevation_30s</span>(<span class="at">country =</span> <span class="st">"CHE"</span>, <span class="at">path =</span> <span class="fu">tempdir</span>())</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>aut_ch <span class="ot">=</span> <span class="fu">merge</span>(aut, ch)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El comando <code>merge()</code> de <strong>terra</strong> combina dos imágenes y, en caso de que se solapen, utiliza el valor de la primera trama.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>