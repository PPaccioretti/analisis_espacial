<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Modificado de https://r.geocompx.org/">

<title>Operaciones geométricas</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="operaciones_geometricas_files/libs/clipboard/clipboard.min.js"></script>
<script src="operaciones_geometricas_files/libs/quarto-html/quarto.js"></script>
<script src="operaciones_geometricas_files/libs/quarto-html/popper.min.js"></script>
<script src="operaciones_geometricas_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="operaciones_geometricas_files/libs/quarto-html/anchor.min.js"></script>
<link href="operaciones_geometricas_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="operaciones_geometricas_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="operaciones_geometricas_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="operaciones_geometricas_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="operaciones_geometricas_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#introducción" id="toc-introducción" class="nav-link active" data-scroll-target="#introducción">Introducción</a></li>
  <li><a href="#operaciones-geométricas-sobre-datos-vectoriales" id="toc-operaciones-geométricas-sobre-datos-vectoriales" class="nav-link" data-scroll-target="#operaciones-geométricas-sobre-datos-vectoriales">Operaciones geométricas sobre datos vectoriales</a>
  <ul class="collapse">
  <li><a href="#simplificación" id="toc-simplificación" class="nav-link" data-scroll-target="#simplificación">Simplificación</a></li>
  <li><a href="#centroides" id="toc-centroides" class="nav-link" data-scroll-target="#centroides">Centroides</a></li>
  <li><a href="#buffers" id="toc-buffers" class="nav-link" data-scroll-target="#buffers">Buffers</a></li>
  <li><a href="#transformaciones-afines" id="toc-transformaciones-afines" class="nav-link" data-scroll-target="#transformaciones-afines">Transformaciones afines</a></li>
  <li><a href="#clipping" id="toc-clipping" class="nav-link" data-scroll-target="#clipping">Clipping</a></li>
  <li><a href="#subsetting-y-clipping" id="toc-subsetting-y-clipping" class="nav-link" data-scroll-target="#subsetting-y-clipping">Subsetting y clipping</a></li>
  <li><a href="#uniones-geométricas" id="toc-uniones-geométricas" class="nav-link" data-scroll-target="#uniones-geométricas">Uniones geométricas</a></li>
  <li><a href="#transformaciones-de-tipo" id="toc-transformaciones-de-tipo" class="nav-link" data-scroll-target="#transformaciones-de-tipo">Transformaciones de tipo</a></li>
  </ul></li>
  <li><a href="#operaciones-geométricas-sobre-datos-raster" id="toc-operaciones-geométricas-sobre-datos-raster" class="nav-link" data-scroll-target="#operaciones-geométricas-sobre-datos-raster">Operaciones geométricas sobre datos raster</a>
  <ul class="collapse">
  <li><a href="#intersecciones-geométricas" id="toc-intersecciones-geométricas" class="nav-link" data-scroll-target="#intersecciones-geométricas">Intersecciones geométricas</a></li>
  <li><a href="#extensión-y-origen" id="toc-extensión-y-origen" class="nav-link" data-scroll-target="#extensión-y-origen">Extensión y origen</a></li>
  <li><a href="#agregación-y-desagregación" id="toc-agregación-y-desagregación" class="nav-link" data-scroll-target="#agregación-y-desagregación">Agregación y desagregación</a></li>
  <li><a href="#remuestreo" id="toc-remuestreo" class="nav-link" data-scroll-target="#remuestreo">Remuestreo</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Operaciones geométricas</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Modificado de <a href="https://r.geocompx.org/" class="uri">https://r.geocompx.org/</a> </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(sf)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(terra)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(spData)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(spDataLarge)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="introducción" class="level2">
<h2 class="anchored" data-anchor-id="introducción">Introducción</h2>
<p>Hasta ahora, hemos visto la estructura de los conjuntos de datos geográficos, y cómo manipularlos basándose en sus atributos no geográficos y relaciones espaciales. Este capítulo se centra en la manipulación de los elementos geográficos de los objetos geográficos, por ejemplo simplificando y convirtiendo geometrías vectoriales, recortando conjuntos de datos ráster y convirtiendo objetos vectoriales en rásteres y rásteres en vectores.</p>
</section>
<section id="operaciones-geométricas-sobre-datos-vectoriales" class="level2">
<h2 class="anchored" data-anchor-id="operaciones-geométricas-sobre-datos-vectoriales">Operaciones geométricas sobre datos vectoriales</h2>
<p>Esta sección trata de las operaciones que de alguna manera cambian la geometría de los objetos vectoriales (<code>sf</code>). Es más avanzada que las operaciones con datos espaciales presentadas anteriormente, porque aquí profundizamos en la geometría: las funciones discutidas en esta sección trabajan sobre objetos de clase <code>sfc</code> además de sobre objetos de clase <code>sf</code>.</p>
<section id="simplificación" class="level3">
<h3 class="anchored" data-anchor-id="simplificación">Simplificación</h3>
<p>La simplificación es un proceso de generalización de objetos vectoriales (líneas y polígonos) que suele utilizarse en mapas de menor escala. Otra razón para simplificar objetos es reducir la cantidad de memoria, espacio en disco y ancho de banda de red que consumen: puede ser conveniente simplificar geometrías complejas antes de publicarlas como mapas interactivos. El paquete <strong>sf</strong> proporciona <code>st_simplify()</code>, que utiliza la implementación GEOS del algoritmo Douglas-Peucker para reducir el número de vértices. <code>st_simplify()</code> utiliza <code>dTolerance</code> para controlar el nivel de generalización en las unidades del mapa. La figura de abajo ilustra la simplificación de una geometría <code>LINESTRING</code> que representa el río Sena y sus afluentes. La geometría simplificada se creó mediante el siguiente comando:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>seine_simp <span class="ot">=</span> <span class="fu">st_simplify</span>(seine, <span class="at">dTolerance =</span> <span class="dv">2000</span>)  <span class="co"># 2000 m</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-fig.asp="0.5">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="operaciones_geometricas_files/figure-html/seine-simp-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Comparison of the original and simplified geometry of the seine object.</figcaption>
</figure>
</div>
</div>
</div>
<p>El objeto <code>seine_simp</code> resultante es una copia del <code>seine</code> original pero con menos vértices.</p>
<p>La simplificación también es aplicable a los polígonos. Esto se ilustra utilizando <code>us_states</code>, que representa los Estados Unidos contiguos. GEOS asume que los datos están en un CRS proyectado y esto podría llevar a resultados inesperados cuando se utiliza un CRS geográfico. Por lo tanto, el primer paso es proyectar los datos en algún CRS proyectado adecuado, como US National Atlas Equal Area (EPSG = 2163):</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>us_states2163 <span class="ot">=</span> <span class="fu">st_transform</span>(us_states, <span class="st">"EPSG:2163"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>st_simplify()</code> funciona igualmente bien con polígonos proyectados:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>us_states_simp1 <span class="ot">=</span> <span class="fu">st_simplify</span>(us_states2163, <span class="at">dTolerance =</span> <span class="dv">100000</span>)  <span class="co"># 100 km</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Una limitación de <code>st_simplify()</code> es que simplifica los objetos por geometría. Esto significa que se pierde la “topología”, lo que da lugar a la superposición y unidades areales con huecos. <code>ms_simplify()</code> de <strong>rmapshaper</strong> proporciona una alternativa que supera este problema. Por defecto utiliza el algoritmo Visvalingam, que supera algunas limitaciones del algoritmo Douglas-Peucker. El siguiente trozo de código utiliza esta función para simplificar <code>us_states2163</code>. El resultado tiene sólo el 1% de los vértices de la entrada (fijados usando el argumento <code>keep</code>) pero su número de objetos permanece intacto porque fijamos <code>keep_shapes = TRUE</code>:<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># proportion of points to retain (0-1; default 0.05)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>us_states_simp2 <span class="ot">=</span> rmapshaper<span class="sc">::</span><span class="fu">ms_simplify</span>(us_states2163, <span class="at">keep =</span> <span class="fl">0.01</span>,</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">keep_shapes =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Una alternativa a la simplificación es el suavizado de los límites de las geometrías poligonales y lineales, que se implementa en el paquete <strong>smoothr</strong>. El suavizado interpola los bordes de las geometrías y no conduce necesariamente a un menor número de vértices, pero puede ser especialmente útil cuando se trabaja con geometrías que surgen de vectorizar espacialmente un raster. <strong>smoothr</strong> implementa tres técnicas de suavizado: una regresión kernel gaussiana, el algoritmo de corte de esquinas de Chaikin y la interpolación spline. Los algoritmos de suavizado tampoco conservan la “topología”. La función principal de <strong>smoothr</strong> es <code>smooth()</code>, donde el argumento <code>method</code> especifica qué técnica de suavizado utilizar. A continuación se muestra un ejemplo de uso de la regresión kernel gaussiana para suavizar las fronteras de los estados de EE.UU. utilizando <code>method=ksmooth</code>. El argumento <code>smoothness</code> controla el ancho de banda de la gaussiana que se utiliza para suavizar la geometría y tiene un valor por defecto de 1.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>us_states_simp3 <span class="ot">=</span> smoothr<span class="sc">::</span><span class="fu">smooth</span>(us_states2163, </span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">method =</span> <span class="st">"ksmooth"</span>, <span class="at">smoothness =</span> <span class="dv">6</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La comparación visual del conjunto de datos original con las versiones simplificada y suavizada se muestra abajo. Pueden observarse diferencias entre los resultados de los algoritmos Douglas-Peucker (<code>st_simplify</code>), Visvalingam (<code>ms_simplify</code>) y regresión kernel gaussiana (<code>smooth(method=ksmooth</code>).</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="operaciones_geometricas_files/figure-html/us-simp-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Polygon simplification in action, comparing the original geometry of the contiguous United States with simplified versions, generated with functions from sf (top-right), rmapshaper (bottom-left), and smoothr (bottom-right) packages.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="centroides" class="level3">
<h3 class="anchored" data-anchor-id="centroides">Centroides</h3>
<p>Las operaciones de centroide identifican el centro de los objetos geográficos. Al igual que las medidas estadísticas de tendencia central, existen muchas formas de definir el centro geográfico de un objeto. Todas ellas crean representaciones de punto único de objetos vectoriales más complejos.</p>
<p>La operación de centroide más utilizada es el <em>centroide geográfico</em>. Este tipo de operación centroide representa el centro de masa de un objeto espacial. Los centroides geográficos tienen muchos usos, por ejemplo para crear una representación simple de puntos de geometrías complejas, o para estimar distancias entre polígonos. Pueden calcularse con la función <strong>sf</strong> <code>st_centroid()</code>, como se demuestra en el código siguiente, que genera los centroides geográficos de regiones de Nueva Zelanda y afluentes del río Sena, ilustrados con puntos negros.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>nz_centroid <span class="ot">=</span> <span class="fu">st_centroid</span>(nz)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>seine_centroid <span class="ot">=</span> <span class="fu">st_centroid</span>(seine)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>A veces, el centroide geográfico cae fuera de los límites de sus objetos padre (piense en un donut). En tales casos, las operaciones <em>punto sobre superficie</em> pueden utilizarse para garantizar que el punto se encuentra en el objeto padre (por ejemplo, para etiquetar objetos multipoligonales irregulares como los estados insulares), como ilustran los puntos rojos de la figura abajo. Observe que estos puntos rojos siempre se encuentran en sus objetos padre. Se crearon con <code>st_point_on_surface()</code> de la siguiente manera:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>nz_pos <span class="ot">=</span> <span class="fu">st_point_on_surface</span>(nz)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>seine_pos <span class="ot">=</span> <span class="fu">st_point_on_surface</span>(seine)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="operaciones_geometricas_files/figure-html/centr-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Centroids (black points) and ‘points on surface’ (red points) of New Zealand’s regions (left) and the Seine (right) datasets.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="buffers" class="level3">
<h3 class="anchored" data-anchor-id="buffers">Buffers</h3>
<p>Los buffers son polígonos que representan el área dentro de una distancia determinada de un elemento geométrico: independientemente de si la entrada es un punto, una línea o un polígono, la salida es un polígono. El buffering suele utilizarse para el análisis de datos geográficos. ¿Cuántos puntos se encuentran a una distancia determinada de esta línea? ¿Qué grupos demográficos se encuentran a una distancia de viaje de esta nueva tienda? Este tipo de preguntas pueden responderse y visualizarse creando buffers alrededor de las entidades geográficas de interés.</p>
<p>La próxima figura ilustra los buffers de diferentes tamaños (5 y 50 km) que rodean el río Sena y sus afluentes. Estos buffers se crearon con los comandos que se indican a continuación, que muestran que el comando <code>st_buffer()</code> requiere al menos dos argumentos: una geometría de entrada y una distancia, proporcionada en las unidades del CRS (en este caso metros):</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>seine_buff_5km <span class="ot">=</span> <span class="fu">st_buffer</span>(seine, <span class="at">dist =</span> <span class="dv">5000</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>seine_buff_50km <span class="ot">=</span> <span class="fu">st_buffer</span>(seine, <span class="at">dist =</span> <span class="dv">50000</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="operaciones_geometricas_files/figure-html/buffs-1.png" class="img-fluid figure-img" style="width:75.0%"></p>
<figcaption class="figure-caption">Buffers around the Seine dataset of 5 km (left) and 50 km (right). Note the colors, which reflect the fact that one buffer is created per geometry feature.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="transformaciones-afines" class="level3">
<h3 class="anchored" data-anchor-id="transformaciones-afines">Transformaciones afines</h3>
<p>Una transformación afín es cualquier transformación que conserva las líneas y el paralelismo. Sin embargo, los ángulos o la longitud no se conservan necesariamente. Las transformaciones afines incluyen, entre otras, el desplazamiento (traslación), la escala y la rotación. Además, es posible utilizar cualquier combinación de ellas. Las transformaciones afines son una parte esencial de la geocomputación. Por ejemplo, el desplazamiento es necesario para la colocación de etiquetas, el escalado se utiliza en cartogramas de áreas no contiguas, y muchas transformaciones afines se aplican al reproyectar o mejorar la geometría que se creó basándose en un mapa distorsionado o mal proyectado. El paquete <strong>sf</strong> implementa transformaciones afines para objetos de las clases <code>sfg</code> y <code>sfc</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>nz_sfc <span class="ot">=</span> <span class="fu">st_geometry</span>(nz)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El desplazamiento mueve cada punto la misma distancia en unidades de mapa. Puede hacerse añadiendo un vector numérico a un objeto vectorial. Por ejemplo, el código siguiente desplaza todas las coordenadas y 100.000 metros hacia el norte, pero deja intactas las coordenadas x.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>nz_shift <span class="ot">=</span> nz_sfc <span class="sc">+</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">100000</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La escala amplía o reduce los objetos en un factor dado. Puede aplicarse global o localmente. El escalado global aumenta o disminuye todos los valores de las coordenadas en relación con las coordenadas de origen, manteniendo intactas todas las relaciones topológicas de las geometrías. Puede realizarse por sustracción o multiplicación de un objeto <code>sfg</code> o <code>sfc</code>.</p>
<p>El escalado local trata las geometrías de forma independiente y requiere puntos alrededor de los cuales se van a escalar las geometrías, por ejemplo, los centroides. En el ejemplo siguiente, cada geometría se reduce en un factor de dos alrededor de los centroides. Para ello, primero se desplaza cada objeto de modo que su centro tenga coordenadas <code>0, 0</code> (<code>(nz_sfc - nz_centroid_sfc)</code>). A continuación, los tamaños de las geometrías se reducen a la mitad (<code>* 0,5</code>). Por último, el centroide de cada objeto se desplaza a las coordenadas de los datos de entrada (<code>+ nz_centroid_sfc</code>).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>nz_centroid_sfc <span class="ot">=</span> <span class="fu">st_centroid</span>(nz_sfc)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>nz_scale <span class="ot">=</span> (nz_sfc <span class="sc">-</span> nz_centroid_sfc) <span class="sc">*</span> <span class="fl">0.5</span> <span class="sc">+</span> nz_centroid_sfc</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La rotación de coordenadas bidimensionales requiere una matriz de rotación:</p>
<p><span class="math display">\[
R =
\begin{bmatrix}
\cos \theta &amp; -\sin \theta \\  
\sin \theta &amp; \cos \theta \\
\end{bmatrix}
\]</span></p>
<p>Ésta gira los puntos en el sentido de las agujas del reloj. La matriz de rotación se puede implementar en R como:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>rotation <span class="ot">=</span> <span class="cf">function</span>(a){</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  r <span class="ot">=</span> a <span class="sc">*</span> pi <span class="sc">/</span> <span class="dv">180</span> <span class="co">#degrees to radians</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="fu">cos</span>(r), <span class="fu">sin</span>(r), <span class="sc">-</span><span class="fu">sin</span>(r), <span class="fu">cos</span>(r)), <span class="at">nrow =</span> <span class="dv">2</span>, <span class="at">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>} </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La función <code>rotation</code> acepta un argumento <code>a</code> - un ángulo de rotación en grados. La rotación puede realizarse alrededor de puntos seleccionados, como los centroides.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>nz_rotate <span class="ot">=</span> (nz_sfc <span class="sc">-</span> nz_centroid_sfc) <span class="sc">*</span> <span class="fu">rotation</span>(<span class="dv">30</span>) <span class="sc">+</span> nz_centroid_sfc</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="operaciones_geometricas_files/figure-html/affine-trans-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Illustrations of affine transformations: shift, scale and rotate.</figcaption>
</figure>
</div>
</div>
</div>
<p>Por último, las geometrías recién creadas pueden sustituir a las antiguas con la función <code>st_set_geometry()</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>nz_scale_sf <span class="ot">=</span> <span class="fu">st_set_geometry</span>(nz, nz_scale)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="clipping" class="level3">
<h3 class="anchored" data-anchor-id="clipping">Clipping</h3>
<p>El recorte espacial es una forma de subset espacial que implica cambios en las columnas <code>geometry</code> de al menos algunas de las características afectadas.</p>
<p>El recorte sólo puede aplicarse a características más complejas que los puntos: líneas, polígonos y sus equivalentes “multi”. Para ilustrar el concepto, empezaremos con un ejemplo sencillo: dos círculos superpuestos con un punto central a una unidad de distancia el uno del otro y un radio de uno.</p>
<div class="cell" data-fig.asp="0.4" data-crop="true">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>b <span class="ot">=</span> <span class="fu">st_sfc</span>(<span class="fu">st_point</span>(<span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1</span>)), <span class="fu">st_point</span>(<span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">1</span>))) <span class="co"># create 2 points</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>b <span class="ot">=</span> <span class="fu">st_buffer</span>(b, <span class="at">dist =</span> <span class="dv">1</span>) <span class="co"># convert points to circles</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(b, <span class="at">border =</span> <span class="st">"grey"</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="fu">text</span>(<span class="at">x =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.5</span>, <span class="fl">1.5</span>), <span class="at">y =</span> <span class="dv">1</span>, <span class="at">labels =</span> <span class="fu">c</span>(<span class="st">"x"</span>, <span class="st">"y"</span>), <span class="at">cex =</span> <span class="dv">3</span>) <span class="co"># add text</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="operaciones_geometricas_files/figure-html/points-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Overlapping circles.</figcaption>
</figure>
</div>
</div>
</div>
<p>Imagina que quieres seleccionar no un círculo u otro, sino el espacio cubierto por <code>x</code> <em>y</em> <code>y</code>. Para ello se utiliza la función <code>st_intersection()</code>, ilustrada con objetos denominados <code>x</code> e <code>y</code>, que representan los círculos izquierdo y derecho.</p>
<div class="cell" data-fig.asp="0.4" data-crop="true">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> b[<span class="dv">1</span>]</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>y <span class="ot">=</span> b[<span class="dv">2</span>]</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>x_and_y <span class="ot">=</span> <span class="fu">st_intersection</span>(x, y)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(b, <span class="at">border =</span> <span class="st">"grey"</span>)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(x_and_y, <span class="at">col =</span> <span class="st">"lightgrey"</span>, <span class="at">border =</span> <span class="st">"grey"</span>, <span class="at">add =</span> <span class="cn">TRUE</span>) <span class="co"># intersecting area</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="operaciones_geometricas_files/figure-html/circle-intersection-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Overlapping circles with a gray color indicating intersection between them.</figcaption>
</figure>
</div>
</div>
</div>
<p>El siguiente fragmento de código demuestra cómo funciona esto para todas las combinaciones del diagrama de Venn que representan <code>x</code> e <code>y</code>, inspirado en la <a href="http://r4ds.had.co.nz/transform.html#logical-operators">Figura 5.1</a> del libro <em>R for Data Science</em>.</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="operaciones_geometricas_files/figure-html/venn-clip-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Spatial equivalents of logical operators.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="subsetting-y-clipping" class="level3">
<h3 class="anchored" data-anchor-id="subsetting-y-clipping">Subsetting y clipping</h3>
<p>Recortar objetos puede cambiar su geometría, pero también puede subdividir objetos, devolviendo sólo las características que se cruzan (o se cruzan parcialmente) con un objeto de recorte/subconjunto. Para ilustrar este punto, vamos a subdividir puntos que cubren el cuadro delimitador de los círculos <code>x</code> e <code>y</code> en la figura anterior. Algunos puntos estarán dentro de un solo círculo, otros dentro de los dos y otros dentro de ninguno. A continuación se utiliza <code>st_sample()</code> para generar una distribución <em>aleatoria</em> de puntos dentro de la extensión de los círculos <code>x</code> e <code>y</code>, planteando la siguiente pregunta: ¿cómo subconjuntar los puntos para devolver sólo el punto que se cruza con <em>ambos</em> <code>x</code> e <code>y</code>?</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>bb <span class="ot">=</span> <span class="fu">st_bbox</span>(<span class="fu">st_union</span>(x, y))</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>box <span class="ot">=</span> <span class="fu">st_as_sfc</span>(bb)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">2017</span>)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>p <span class="ot">=</span> <span class="fu">st_sample</span>(<span class="at">x =</span> box, <span class="at">size =</span> <span class="dv">10</span>)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>p_xy1 <span class="ot">=</span> p[x_and_y]</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(box, <span class="at">border =</span> <span class="st">"grey"</span>, <span class="at">lty =</span> <span class="dv">2</span>)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(x, <span class="at">add =</span> <span class="cn">TRUE</span>, <span class="at">border =</span> <span class="st">"grey"</span>)</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(y, <span class="at">add =</span> <span class="cn">TRUE</span>, <span class="at">border =</span> <span class="st">"grey"</span>)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(p, <span class="at">add =</span> <span class="cn">TRUE</span>)</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(p_xy1, <span class="at">cex =</span> <span class="dv">3</span>, <span class="at">col =</span> <span class="st">"red"</span>, <span class="at">add =</span> <span class="cn">TRUE</span>)</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span class="fu">text</span>(<span class="at">x =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.5</span>, <span class="fl">1.5</span>), <span class="at">y =</span> <span class="dv">1</span>, <span class="at">labels =</span> <span class="fu">c</span>(<span class="st">"x"</span>, <span class="st">"y"</span>), <span class="at">cex =</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="operaciones_geometricas_files/figure-html/venn-subset-1.png" class="img-fluid figure-img" width="864"></p>
<figcaption class="figure-caption">Randomly distributed points within the bounding box enclosing circles x and y. The point that intersects with both objects x and y is highlighted.</figcaption>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>bb <span class="ot">=</span> <span class="fu">st_bbox</span>(<span class="fu">st_union</span>(x, y))</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>box <span class="ot">=</span> <span class="fu">st_as_sfc</span>(bb)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">2017</span>)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>p <span class="ot">=</span> <span class="fu">st_sample</span>(<span class="at">x =</span> box, <span class="at">size =</span> <span class="dv">10</span>)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>x_and_y <span class="ot">=</span> <span class="fu">st_intersection</span>(x, y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El siguiente fragmento de código muestra tres formas de conseguir el mismo resultado. Podemos utilizar la intersección de <code>x</code> y <code>y</code> (representados por <code>x_and_y</code> en el fragmento de código anterior) como un objeto de subconjunto directamente, como se muestra en la primera línea en el fragmento de código a continuación. También podemos encontrar la <em>intersección</em> entre los puntos de entrada representados por <code>p</code> y el objeto de subconjunto/recorte <code>x_and_y</code>, como se muestra en la segunda línea del fragmento de código siguiente. Este segundo enfoque devolverá características que se intersecan parcialmente con <code>x_and_y</code> pero con geometrías modificadas para características espacialmente extensas que cruzan la frontera del objeto de subconjunto. El tercer enfoque consiste en crear un objeto de subconjunto utilizando el predicado espacial binario <code>st_intersects()</code>. Los resultados son idénticos (salvo diferencias superficiales en los nombres de los atributos), pero la implementación difiere sustancialmente:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>p_xy1 <span class="ot">=</span> p[x_and_y] <span class="co"># way #1</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>p_xy2 <span class="ot">=</span> <span class="fu">st_intersection</span>(p, x_and_y) <span class="co"># way #2</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>sel_p_xy <span class="ot">=</span> <span class="fu">st_intersects</span>(p, x, <span class="at">sparse =</span> <span class="cn">FALSE</span>)[, <span class="dv">1</span>] <span class="sc">&amp;</span> </span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">st_intersects</span>(p, y, <span class="at">sparse =</span> <span class="cn">FALSE</span>)[, <span class="dv">1</span>] <span class="co"># way #3</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>p_xy3 <span class="ot">=</span> p[sel_p_xy]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="uniones-geométricas" class="level3">
<h3 class="anchored" data-anchor-id="uniones-geométricas">Uniones geométricas</h3>
<p>La agregación espacial puede disolver silenciosamente las geometrías de los polígonos que se tocan en el mismo grupo. Esto se demuestra en el fragmento de código siguiente, en el que 49 <code>us_states</code> se agregan en cuatro regiones utilizando las funciones base y <strong>dplyr</strong>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>regions <span class="ot">=</span> <span class="fu">aggregate</span>(<span class="at">x =</span> us_states[, <span class="st">"total_pop_15"</span>], <span class="at">by =</span> <span class="fu">list</span>(us_states<span class="sc">$</span>REGION),</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>                    <span class="at">FUN =</span> sum, <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>regions2 <span class="ot">=</span> us_states <span class="sc">|&gt;</span> </span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(REGION) <span class="sc">|&gt;</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarize</span>(<span class="at">pop =</span> <span class="fu">sum</span>(total_pop_15, <span class="at">na.rm =</span> <span class="cn">TRUE</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="operaciones_geometricas_files/figure-html/us-regions-1.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption class="figure-caption">Spatial aggregation on contiguous polygons, illustrated by aggregating the population of US states into regions, with population represented by color. Note the operation automatically dissolves boundaries between states.</figcaption>
</figure>
</div>
</div>
</div>
<p>¿Qué ocurre con las geometrías? Entre bastidores, tanto <code>aggregate()</code> como <code>summarize()</code> combinan las geometrías y disuelven los límites entre ellas utilizando <code>st_union()</code>. Esto se demuestra en el fragmento de código siguiente, que crea un oeste de EE.UU. unido:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>us_west <span class="ot">=</span> us_states[us_states<span class="sc">$</span>REGION <span class="sc">==</span> <span class="st">"West"</span>, ]</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>us_west_union <span class="ot">=</span> <span class="fu">st_union</span>(us_west)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La función puede tomar dos geometrías y unirlas, como se demuestra en el siguiente fragmento de código que crea un bloque occidental unido que incorpora Texas:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>texas <span class="ot">=</span> us_states[us_states<span class="sc">$</span>NAME <span class="sc">==</span> <span class="st">"Texas"</span>, ]</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>texas_union <span class="ot">=</span> <span class="fu">st_union</span>(us_west_union, texas)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="transformaciones-de-tipo" class="level3">
<h3 class="anchored" data-anchor-id="transformaciones-de-tipo">Transformaciones de tipo</h3>
<p>Geometry casting es una potente operación que permite transformar el tipo de geometría. Está implementada en la función <code>st_cast()</code> del paquete <strong>sf</strong>. Es importante destacar que <code>st_cast()</code> se comporta de forma diferente en objetos de geometría simple (<code>sfg</code>) y objetos de geometría simple en columna (<code>sfc</code>).</p>
<p>Vamos a crear un multipunto para ilustrar cómo funciona el cambio de geometría en objetos de geometría simple (<code>sfg</code>):</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>multipoint <span class="ot">=</span> <span class="fu">st_multipoint</span>(<span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">1</span>), <span class="at">ncol =</span> <span class="dv">2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>En este caso, <code>st_cast()</code> puede ser útil para transformar el nuevo objeto en una cadena de líneas o un polígono:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>linestring <span class="ot">=</span> <span class="fu">st_cast</span>(multipoint, <span class="st">"LINESTRING"</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>polyg <span class="ot">=</span> <span class="fu">st_cast</span>(multipoint, <span class="st">"POLYGON"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-fig.asp="0.3">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="operaciones_geometricas_files/figure-html/single-cast-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Examples of a linestring and a polygon casted from a multipoint geometry.</figcaption>
</figure>
</div>
</div>
</div>
<p>La conversión de multipunto a cadena de líneas es una operación habitual que crea un objeto de línea a partir de observaciones de puntos ordenados, como mediciones GPS o medios geoetiquetados. Esto, a su vez, permite realizar operaciones espaciales como el cálculo de la longitud del camino recorrido. La conversión de multipunto o cadena de líneas a polígono se utiliza a menudo para calcular un área, por ejemplo a partir del conjunto de mediciones GPS tomadas alrededor de un lago o de las esquinas de un solar.</p>
<p>El proceso de transformación también puede invertirse utilizando <code>st_cast()</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>multipoint_2 <span class="ot">=</span> <span class="fu">st_cast</span>(linestring, <span class="st">"MULTIPOINT"</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>multipoint_3 <span class="ot">=</span> <span class="fu">st_cast</span>(polyg, <span class="st">"MULTIPOINT"</span>)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="fu">all.equal</span>(multipoint, multipoint_2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] TRUE</code></pre>
</div>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">all.equal</span>(multipoint, multipoint_3)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] TRUE</code></pre>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Para geometrías simples (<code>sfg</code>), <code>st_cast()</code> también permite pasar geometrías de no multitipos a multitipos (por ejemplo, de <code>POINT</code> a <code>MULTIPOINT</code>) y de multitipos a no multitipos. Sin embargo, al pasar de multitipos a no multitipos, sólo el primer elemento del objeto antiguo permanecerá en el objeto de salida.</p>
</div>
</div>
<p>La conversión geométrica de la columna geométrica de características simples (<code>sfc</code>) y los objetos de características simples funciona igual que para <code>sfg</code> en la mayoría de los casos. Una diferencia importante es la conversión de multitipos a no multitipos. Como resultado de este proceso, los objetos múltiples de <code>sfc</code> o <code>sf</code> se dividen en muchos objetos no múltiples.</p>
<p>La tabla de abajo muestra las posibles transformaciones del tipo de geometría en objetos sf. Las geometrías de sf (representadas por la primera columna de la tabla) pueden transformarse en múltiples tipos de geometría, representados por las columnas de la tabla abajo. Algunas transformaciones no son posibles: no se puede convertir un único punto en una multilínea o un polígono, por ejemplo, lo que explica por qué las celdas <code>[1, 4:5]</code> de la tabla contienen NA. Algunas transformaciones dividen la entrada de una única característica en múltiples subcaracterísticas, “expandiendo” objetos <code>sf</code> (añadiendo nuevas filas con valores de atributos duplicados). Cuando una geometría multipunto que consta de cinco pares de coordenadas se transforma en una geometría “PUNTO”, por ejemplo, la salida contendrá cinco características.</p>
<div class="cell">
<div class="cell-output-display">
<table data-quarto-postprocess="true" class="table table-sm table-striped small">
<caption>Geometry casting on simple feature geometries (see Section 2.1) with input type by row and output type by column</caption>
<thead>
<tr class="header">
<th style="text-align: left;" data-quarto-table-cell-role="th"></th>
<th style="text-align: right;" data-quarto-table-cell-role="th">POI</th>
<th style="text-align: right;" data-quarto-table-cell-role="th">MPOI</th>
<th style="text-align: right;" data-quarto-table-cell-role="th">LIN</th>
<th style="text-align: right;" data-quarto-table-cell-role="th">MLIN</th>
<th style="text-align: right;" data-quarto-table-cell-role="th">POL</th>
<th style="text-align: right;" data-quarto-table-cell-role="th">MPOL</th>
<th style="text-align: right;" data-quarto-table-cell-role="th">GC</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">POI(1)</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">NA</td>
<td style="text-align: right;">NA</td>
<td style="text-align: right;">NA</td>
<td style="text-align: right;">NA</td>
</tr>
<tr class="even">
<td style="text-align: left;">MPOI(1)</td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">NA</td>
<td style="text-align: right;">NA</td>
</tr>
<tr class="odd">
<td style="text-align: left;">LIN(1)</td>
<td style="text-align: right;">5</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">NA</td>
<td style="text-align: right;">NA</td>
</tr>
<tr class="even">
<td style="text-align: left;">MLIN(1)</td>
<td style="text-align: right;">7</td>
<td style="text-align: right;">2</td>
<td style="text-align: right;">2</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">NA</td>
<td style="text-align: right;">NA</td>
<td style="text-align: right;">NA</td>
</tr>
<tr class="odd">
<td style="text-align: left;">POL(1)</td>
<td style="text-align: right;">5</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">NA</td>
</tr>
<tr class="even">
<td style="text-align: left;">MPOL(1)</td>
<td style="text-align: right;">10</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">NA</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">2</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">GC(1)</td>
<td style="text-align: right;">9</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">NA</td>
<td style="text-align: right;">NA</td>
<td style="text-align: right;">NA</td>
<td style="text-align: right;">NA</td>
<td style="text-align: right;">1</td>
</tr>
</tbody><tfoot>
<tr class="even">
<td style="text-align: left; padding: 0; border: 0;"><sup></sup> Note: Values like (1) represent the number of features; NA means the operation is not possible. Abbreviations: POI, LIN, POL and GC refer to POINT, LINESTRING, POLYGON and GEOMETRYCOLLECTION. The MULTI version of these geometry types is indicated by a preceding M, e.g., MPOI is the acronym for MULTIPOINT.</td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
</tr>
</tfoot>

</table>


</div>
</div>
<p>Intentemos aplicar transformaciones de tipo geométrico sobre un nuevo objeto, <code>multilinestring_sf</code>, como ejemplo :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>multilinestring_list <span class="ot">=</span> <span class="fu">list</span>(<span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">3</span>), <span class="at">ncol =</span> <span class="dv">2</span>), </span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>                            <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">1</span>), <span class="at">ncol =</span> <span class="dv">2</span>),</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>                            <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">2</span>), <span class="at">ncol =</span> <span class="dv">2</span>))</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>multilinestring <span class="ot">=</span> <span class="fu">st_multilinestring</span>(multilinestring_list)</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>multilinestring_sf <span class="ot">=</span> <span class="fu">st_sf</span>(<span class="at">geom =</span> <span class="fu">st_sfc</span>(multilinestring))</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>multilinestring_sf</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="kable-table">

<table>
<thead>
<tr>
<th style="text-align:left;">
geom
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
MULTILINESTRING ((1 5, 4 3)…
</td>
</tr>
</tbody>

</table>
</div>
</div>
</div>
<p>Puede imaginárselo como una red de carreteras o ríos. El nuevo objeto sólo tiene una fila que define todas las líneas. Esto restringe el número de operaciones que se pueden realizar, por ejemplo impide añadir nombres a cada segmento de línea o calcular longitudes de líneas individuales. La función <code>st_cast()</code> puede utilizarse en esta situación, ya que separa una mutlilínea en tres líneas:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>linestring_sf2 <span class="ot">=</span> <span class="fu">st_cast</span>(multilinestring_sf, <span class="st">"LINESTRING"</span>)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>linestring_sf2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="kable-table">

<table>
<thead>
<tr>
<th style="text-align:left;">
geom
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
LINESTRING (1 5, 4 3)
</td>
</tr>
<tr>
<td style="text-align:left;">
LINESTRING (4 4, 4 1)
</td>
</tr>
<tr>
<td style="text-align:left;">
LINESTRING (2 2, 4 2)
</td>
</tr>
</tbody>

</table>
</div>
</div>
</div>
<div class="cell">
<div class="cell-output cell-output-stderr">
<pre><code>Multiple palettes called "set2 found: "brewer.set2", "hcl.set2". The first one, "brewer.set2", is returned.</code></pre>
</div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="operaciones_geometricas_files/figure-html/line-cast-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Examples of type casting between MULTILINESTRING (left) and LINESTRING (right).</figcaption>
</figure>
</div>
</div>
</div>
<p>El objeto recién creado permite la creación de atributos y mediciones de longitud:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>linestring_sf2<span class="sc">$</span>name <span class="ot">=</span> <span class="fu">c</span>(<span class="st">"Riddle Rd"</span>, <span class="st">"Marshall Ave"</span>, <span class="st">"Foulke St"</span>)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>linestring_sf2<span class="sc">$</span>length <span class="ot">=</span> <span class="fu">st_length</span>(linestring_sf2)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>linestring_sf2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="kable-table">

<table>
<thead>
<tr>
<th style="text-align:left;">
geom
</th>
<th style="text-align:left;">
name
</th>
<th style="text-align:right;">
length
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
LINESTRING (1 5, 4 3)
</td>
<td style="text-align:left;">
Riddle Rd
</td>
<td style="text-align:right;">
3.605551
</td>
</tr>
<tr>
<td style="text-align:left;">
LINESTRING (4 4, 4 1)
</td>
<td style="text-align:left;">
Marshall Ave
</td>
<td style="text-align:right;">
3.000000
</td>
</tr>
<tr>
<td style="text-align:left;">
LINESTRING (2 2, 4 2)
</td>
<td style="text-align:left;">
Foulke St
</td>
<td style="text-align:right;">
2.000000
</td>
</tr>
</tbody>

</table>
</div>
</div>
</div>
</section>
</section>
<section id="operaciones-geométricas-sobre-datos-raster" class="level2">
<h2 class="anchored" data-anchor-id="operaciones-geométricas-sobre-datos-raster">Operaciones geométricas sobre datos raster</h2>
<p>Las operaciones geométricas ráster incluyen el desplazamiento, la inversión, el reflejo, la escala, la rotación o la deformación de imágenes. Estas operaciones son necesarias para diversas aplicaciones, como la georreferenciación, que permite superponer imágenes en un mapa con un CRS conocido. Existen diversas técnicas de georreferenciación, entre las que se incluyen:</p>
<ul>
<li>Georrectificación basada en <a href="https://www.qgistutorials.com/en/docs/3/georeferencing_basics.html">puntos de control terrestre conocidos</a></li>
<li>Ortorectificación, que también tiene en cuenta la topografía local</li>
<li>El <a href="https://en.wikipedia.org/wiki/Image_registration">co-registro de imágenes</a> se utiliza para combinar imágenes del mismo objeto pero tomadas con sensores diferentes, alineando una imagen con otra (en términos de sistema de coordenadas y resolución).</li>
</ul>
<p>R es bastante inadecuado para los dos primeros puntos, ya que a menudo requieren una intervención manual, por lo que suelen realizarse con la ayuda de software SIG específico. Por otro lado, alinear varias imágenes es posible en R y esta sección muestra, entre otras cosas, cómo hacerlo. Esto incluye a menudo cambiar la extensión, la resolución y el origen de una imagen. Por supuesto, también se requiere una proyección que coincida.</p>
<section id="intersecciones-geométricas" class="level3">
<h3 class="anchored" data-anchor-id="intersecciones-geométricas">Intersecciones geométricas</h3>
<p>Hemos mostrado cómo extraer valores de un ráster superpuesto por otros objetos espaciales. Para recuperar una salida espacial, podemos utilizar casi la misma sintaxis de subset. La única diferencia es que tenemos que dejar claro que queremos mantener la estructura matricial estableciendo el argumento <code>drop</code> en <code>FALSE</code>. Esto devolverá un objeto raster que contiene las celdas cuyos puntos medios se solapan con <code>clip</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>elev <span class="ot">=</span> <span class="fu">rast</span>(<span class="fu">system.file</span>(<span class="st">"raster/elev.tif"</span>, <span class="at">package =</span> <span class="st">"spData"</span>))</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>clip <span class="ot">=</span> <span class="fu">rast</span>(<span class="at">xmin =</span> <span class="fl">0.9</span>, <span class="at">xmax =</span> <span class="fl">1.8</span>, <span class="at">ymin =</span> <span class="sc">-</span><span class="fl">0.45</span>, <span class="at">ymax =</span> <span class="fl">0.45</span>,</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>            <span class="at">resolution =</span> <span class="fl">0.3</span>, <span class="at">vals =</span> <span class="fu">rep</span>(<span class="dv">1</span>, <span class="dv">9</span>))</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>elev[clip, drop <span class="ot">=</span> <span class="cn">FALSE</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>class       : SpatRaster 
dimensions  : 2, 1, 1  (nrow, ncol, nlyr)
resolution  : 0.5, 0.5  (x, y)
extent      : 1, 1.5, -0.5, 0.5  (xmin, xmax, ymin, ymax)
coord. ref. : lon/lat WGS 84 (EPSG:4326) 
source(s)   : memory
varname     : elev 
name        : elev 
min value   :   18 
max value   :   24 </code></pre>
</div>
</div>
<p>Para la misma operación también podemos utilizar el comando <code>intersect()</code> y <code>crop()</code>.</p>
</section>
<section id="extensión-y-origen" class="level3">
<h3 class="anchored" data-anchor-id="extensión-y-origen">Extensión y origen</h3>
<p>Cuando fusionamos o realizamos álgebra de mapas sobre rásters, su resolución, proyección, origen y/o extensión tienen que coincidir. De lo contrario, ¿cómo podríamos sumar los valores de un ráster con una resolución de 0.2 grados decimales a un segundo ráster con una resolución de 1 grado decimal? El mismo problema se plantea cuando queremos fusionar imágenes de satélite procedentes de distintos sensores con proyecciones y resoluciones diferentes. Los desajustes pueden resolverse alineando los rásters.</p>
<p>En el caso más sencillo, dos imágenes sólo difieren en su extensión. El código siguiente añade una fila y dos columnas a cada lado del ráster y establece todos los valores nuevos en <code>NA</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>elev <span class="ot">=</span> <span class="fu">rast</span>(<span class="fu">system.file</span>(<span class="st">"raster/elev.tif"</span>, <span class="at">package =</span> <span class="st">"spData"</span>))</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>elev_2 <span class="ot">=</span> <span class="fu">extend</span>(elev, <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-fig.asp="0.5">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="operaciones_geometricas_files/figure-html/extend-example-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Original raster (left) and the same raster (right) extended by one row on the top and bottom and two columns on the left and right.</figcaption>
</figure>
</div>
</div>
</div>
<p>Al realizar una operación algebraica sobre dos objetos con extensiones diferentes en R, el paquete <strong>terra</strong> devuelve un error.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>elev_3 <span class="ot">=</span> elev <span class="sc">+</span> elev_2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre><code>Error: [+] extents do not match</code></pre>
</div>
</div>
<p>Sin embargo, podemos alinear la extensión de dos rásters con <code>extend()</code>. En lugar de decirle a la función cuántas filas o columnas deben añadirse (como se ha hecho antes), le permitimos que lo averigüe utilizando otro objeto raster. En este caso, ampliamos el objeto <code>elev</code> hasta la extensión <code>elev_2</code>. Los valores de las filas y columnas recién añadidas se fijan en <code>NA</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>elev_4 <span class="ot">=</span> <span class="fu">extend</span>(elev, elev_2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El origen de un raster es la esquina de la celda más cercana a las coordenadas (0, 0). La función <code>origin()</code> devuelve las coordenadas del origen. En el siguiente ejemplo existe una esquina de celda con coordenadas (0, 0), pero no es necesariamente el caso.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="fu">origin</span>(elev_4)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0 0</code></pre>
</div>
</div>
<p>Si dos rásters tienen orígenes diferentes, sus celdas no se solapan completamente, lo que haría imposible el álgebra de mapas. Para cambiar el origen, utilice <code>origin()</code>.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> La próxima figura muestra el efecto de cambiar el origen de esta forma.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co"># change the origin</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="fu">origin</span>(elev_4) <span class="ot">=</span> <span class="fu">c</span>(<span class="fl">0.25</span>, <span class="fl">0.25</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="operaciones_geometricas_files/figure-html/origin-example-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Rasters with identical values but different origins.</figcaption>
</figure>
</div>
</div>
</div>
<p>Tenga en cuenta que al cambiar la resolución (apartado siguiente) también cambia con frecuencia el origen.</p>
</section>
<section id="agregación-y-desagregación" class="level3">
<h3 class="anchored" data-anchor-id="agregación-y-desagregación">Agregación y desagregación</h3>
<p>Los conjuntos de datos ráster también pueden diferir en cuanto a su resolución. Para igualar las resoluciones, se puede disminuir (<code>aggregate()</code>) o aumentar (<code>disagg()</code>) la resolución de un raster.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> Como ejemplo, aquí cambiamos la resolución espacial de <code>dem</code> (que se encuentra en el paquete <strong>spDataLarge</strong>) por un factor de 5. Además, el valor de la celda de salida debe corresponder a la media de las celdas de entrada (tenga en cuenta que también se podrían utilizar otras funciones, como <code>median()</code>, <code>sum()</code>, etc.):</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>dem <span class="ot">=</span> <span class="fu">rast</span>(<span class="fu">system.file</span>(<span class="st">"raster/dem.tif"</span>, <span class="at">package =</span> <span class="st">"spDataLarge"</span>))</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>dem_agg <span class="ot">=</span> <span class="fu">aggregate</span>(dem, <span class="at">fact =</span> <span class="dv">5</span>, <span class="at">fun =</span> mean)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="operaciones_geometricas_files/figure-html/aggregate-example-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Original raster (left). Aggregated raster (right).</figcaption>
</figure>
</div>
</div>
</div>
<p>La función <code>disagg()</code> aumenta la resolución de los objetos raster. Dispone de dos métodos para calcular los valores de las celdas recién creadas: el método por defecto (<code>method = "near"</code>) simplemente da a todas las celdas de salida el valor de la celda de entrada y, por tanto, duplica los valores, lo que se traduce en una salida “en bloque”. El método <code>bilineal</code> utiliza los cuatro centros de píxel más cercanos de la imagen de entrada para calcular un promedio ponderado por la distancia. El valor de la celda de salida está representado por un cuadrado en la esquina superior izquierda.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>dem_disagg <span class="ot">=</span> <span class="fu">disagg</span>(dem_agg, <span class="at">fact =</span> <span class="dv">5</span>, <span class="at">method =</span> <span class="st">"bilinear"</span>)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="fu">identical</span>(dem, dem_disagg)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] FALSE</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="operaciones_geometricas_files/figure-html/bilinear-1.png" class="img-fluid figure-img" width="768"></p>
<figcaption class="figure-caption">The distance-weighted average of the four closest input cells determine the output when using the bilinear method for disaggregation.</figcaption>
</figure>
</div>
</div>
</div>
<p>La comparación de los valores de <code>dem</code> y <code>dem_disagg</code> nos indica que no son idénticos (también puede utilizar <code>compareGeom()</code> o <code>all.equal()</code>). Sin embargo, esto no era de esperar, ya que la desagregación es una simple técnica de interpolación. Es importante tener en cuenta que la desagregación da como resultado una resolución más fina; los valores correspondientes, sin embargo, sólo son tan precisos como su fuente de menor resolución.</p>
</section>
<section id="remuestreo" class="level3">
<h3 class="anchored" data-anchor-id="remuestreo">Remuestreo</h3>
<p>Los métodos anteriores de agregación y desagregación sólo son adecuados cuando queremos cambiar la resolución de nuestro ráster mediante el factor de agregación/desagregación. Sin embargo, ¿qué hacer cuando tenemos dos o más rásters con resoluciones y orígenes diferentes? Esta es la función del remuestreo, un proceso de cálculo de valores para las nuevas ubicaciones de los píxeles. En resumen, este proceso toma los valores de nuestro ráster original y recalcula nuevos valores para un ráster de destino con resolución y origen personalizados.</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="operaciones_geometricas_files/figure-html/resampl0-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Resampling of an original (input) raster into a target raster with custom resolution and origin.</figcaption>
</figure>
</div>
</div>
</div>
<p>Existen varios métodos para estimar los valores de un ráster con diferentes resoluciones/orígenes. Los principales métodos de remuestreo son</p>
<ul>
<li>Vecino más cercano: asigna el valor de la celda más cercana del ráster original a la celda del objetivo. Se trata de una técnica rápida y sencilla que suele ser adecuada para el remuestreo de rásters categóricos.</li>
<li>Interpolación bilineal: asigna una media ponderada de las cuatro celdas más cercanas del raster original a la celda del raster de destino. Es el método más rápido y apropiado para rásters continuos.</li>
<li>Interpolación cúbica: utiliza los valores de las 16 celdas más cercanas del ráster original para determinar el valor de la celda de salida, aplicando funciones polinómicas de tercer orden. Se utiliza para rásters continuos y da como resultado una superficie más suave en comparación con la interpolación bilineal, pero es computacionalmente más exigente.</li>
<li>Interpolación spline cúbica: también utiliza los valores de las 16 celdas más cercanas del ráster original para determinar el valor de la celda de salida, pero aplica splines cúbicos (funciones polinómicas de tercer orden a trozos). Se utiliza para raster continuos.</li>
<li>Remuestreo sinc con ventana de Lanczos: utiliza los valores de las 36 celdas más cercanas del raster original para determinar el valor de la celda de salida. Se utiliza para los raster continuos.</li>
</ul>
<p>La explicación anterior pone de relieve que sólo el remuestreo de <em>vecino más próximo</em> es adecuado para los rásteres categóricos, mientras que todos los métodos pueden utilizarse (con diferentes resultados) para los rásteres continuos. Tenga en cuenta también que los métodos ganan en complejidad y tiempo de procesamiento de arriba a abajo.</p>
<p>Para aplicar el remuestreo, el paquete <strong>terra</strong> proporciona una función <code>resample()</code>. Acepta un ráster de entrada (<code>x</code>), un ráster objetivo (<code>y</code>) y un método de remuestreo (<code>method</code>).</p>
<p>Necesitamos un ráster objetivo para ver cómo funciona la función <code>resample()</code>. Para este ejemplo, creamos <code>target_rast</code>, pero a menudo se utiliza un objeto raster ya existente.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>target_rast <span class="ot">=</span> <span class="fu">rast</span>(<span class="at">xmin =</span> <span class="dv">794650</span>, <span class="at">xmax =</span> <span class="dv">798250</span>, </span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>                   <span class="at">ymin =</span> <span class="dv">8931750</span>, <span class="at">ymax =</span> <span class="dv">8935350</span>,</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>                   <span class="at">resolution =</span> <span class="dv">300</span>, <span class="at">crs =</span> <span class="st">"EPSG:32717"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>A continuación, tenemos que proporcionar nuestros dos objetos raster como los dos primeros argumentos y uno de los métodos de remuestreo descritos anteriormente.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>dem_resampl <span class="ot">=</span> <span class="fu">resample</span>(dem, <span class="at">y =</span> target_rast, <span class="at">method =</span> <span class="st">"bilinear"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La próxima figura muestra una comparación de diferentes métodos de remuestreo en el objeto <code>dem</code>.</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="operaciones_geometricas_files/figure-html/resampl-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Visual comparison of the original raster and five different resampling methods.</figcaption>
</figure>
</div>
</div>
</div>
<p>La función <code>resample()</code> también tiene algunos métodos de remuestreo adicionales, como <code>sum</code>, <code>min</code>, <code>q1</code>, <code>med</code>, <code>q3</code>, <code>max</code>, <code>average</code>, <code>mode</code> y <code>rms</code>. Todos ellos calculan una estadística determinada basándose en los valores de todas las celdas de la cuadrícula que no son NA. Por ejemplo, <code>sum</code> es útil cuando cada celda raster representa una variable espacialmente extensa (por ejemplo, el número de personas). Como consecuencia del uso de <code>sum</code>, el ráster remuestreado debería tener el mismo número total de personas que el original.</p>
<p>La reproyección de raster es un caso especial de remuestreo cuando nuestro raster de destino tiene un CRS diferente al del raster original.</p>
</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p> La simplificación de objetos multipoligonales puede eliminar pequeños polígonos internos, incluso si el argumento <code>keep_shapes</code> está ajustado a TRUE. Para evitar esto, es necesario establecer <code>explode = TRUE</code>. Esta opción convierte todos los mutlipolígonos en polígonos separados antes de su simplificación.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p> Si los orígenes de dos conjuntos de datos ráster están sólo marginalmente separados, a veces es suficiente simplemente aumentar el argumento <code>tolerance</code> de <code>terra::terraOptions()</code>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p> Aquí nos referimos a la resolución espacial. En teledetección también son importantes la resolución espectral (bandas espectrales), temporal (observaciones a lo largo del tiempo de la misma zona) y radiométrica (profundidad de color). Consulte el ejemplo <code>tapp()</code> de la documentación para hacerse una idea de cómo realizar la agregación temporal de rásters.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>