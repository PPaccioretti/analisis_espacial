<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Modificado de https://r.geocompx.org/">

<title>Interacciones raster-vector</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="interaccion_raster_vector_files/libs/clipboard/clipboard.min.js"></script>
<script src="interaccion_raster_vector_files/libs/quarto-html/quarto.js"></script>
<script src="interaccion_raster_vector_files/libs/quarto-html/popper.min.js"></script>
<script src="interaccion_raster_vector_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="interaccion_raster_vector_files/libs/quarto-html/anchor.min.js"></script>
<link href="interaccion_raster_vector_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="interaccion_raster_vector_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="interaccion_raster_vector_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="interaccion_raster_vector_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="interaccion_raster_vector_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#introducción" id="toc-introducción" class="nav-link active" data-scroll-target="#introducción">Introducción</a></li>
  <li><a href="#recorte" id="toc-recorte" class="nav-link" data-scroll-target="#recorte">Recorte</a></li>
  <li><a href="#extracción-de-datos-de-un-raster" id="toc-extracción-de-datos-de-un-raster" class="nav-link" data-scroll-target="#extracción-de-datos-de-un-raster">Extracción de datos de un raster</a></li>
  <li><a href="#rasterización" id="toc-rasterización" class="nav-link" data-scroll-target="#rasterización">Rasterización</a></li>
  <li><a href="#vectorización-espacial" id="toc-vectorización-espacial" class="nav-link" data-scroll-target="#vectorización-espacial">Vectorización espacial</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Interacciones raster-vector</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Modificado de <a href="https://r.geocompx.org/" class="uri">https://r.geocompx.org/</a> </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(sf)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(terra)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="introducción" class="level2">
<h2 class="anchored" data-anchor-id="introducción">Introducción</h2>
<p>Este capítulo se centra en las interacciones entre los modelos de datos geográficos ráster y vectoriales. Incluye cuatro técnicas principales: recorte y enmascaramiento ráster utilizando objetos vectoriales; extracción de valores ráster utilizando diferentes tipos de datos vectoriales; y conversión ráster-vector.</p>
</section>
<section id="recorte" class="level2">
<h2 class="anchored" data-anchor-id="recorte">Recorte</h2>
<p>Muchos proyectos de datos geográficos implican la integración de datos de muchas fuentes diferentes, como imágenes de teledetección (rásters) y límites administrativos (vectores). A menudo, la extensión de los conjuntos de datos ráster de entrada es mayor que el área de interés. En este caso, el <strong>recorte</strong> y el <strong>enmascaramiento</strong> ráster son útiles para unificar la extensión espacial de los datos de entrada. Ambas operaciones reducen el uso de memoria del objeto y los recursos computacionales asociados para los pasos de análisis posteriores, y pueden ser un paso de preprocesamiento necesario antes de crear mapas atractivos que incluyan datos ráster.</p>
<p>Utilizaremos dos objetos para ilustrar el recorte raster:</p>
<ul>
<li>Un objeto <code>SpatRaster</code> <code>srtm</code> que representa la elevación (metros sobre el nivel del mar) en el suroeste de Utah</li>
<li>Un objeto vectorial (<code>sf</code>) <code>zion</code> que representa el Parque Nacional de Zion.</li>
</ul>
<p>Tanto el objeto de destino como el de recorte deben tener la misma proyección. Por lo tanto, el siguiente fragmento de código no sólo lee los conjuntos de datos del paquete <strong>spDataLarge</strong>, sino que también “reproyecta” <code>zion</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>srtm <span class="ot">=</span> <span class="fu">rast</span>(<span class="fu">system.file</span>(<span class="st">"raster/srtm.tif"</span>, <span class="at">package =</span> <span class="st">"spDataLarge"</span>))</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>zion <span class="ot">=</span> <span class="fu">read_sf</span>(<span class="fu">system.file</span>(<span class="st">"vector/zion.gpkg"</span>, <span class="at">package =</span> <span class="st">"spDataLarge"</span>))</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>zion <span class="ot">=</span> <span class="fu">st_transform</span>(zion, <span class="fu">crs</span>(srtm))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Utilizamos <code>crop()</code> del paquete <strong>terra</strong> para recortar <code>srtm</code>. La función reduce la extensión rectangular del objeto pasado como primer argumento en función de la extensión del objeto pasado como segundo argumento.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>srtm_cropped <span class="ot">=</span> <span class="fu">crop</span>(srtm, zion)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Relacionada con <code>crop()</code> está la función <strong>terra</strong> <code>mask()</code>, que establece como <code>NA</code> los valores fuera de los límites del objeto pasado a su segundo argumento. Por tanto, el siguiente comando enmascara todas las celdas situadas fuera de los límites del Parque Nacional de Zion:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>srtm_masked <span class="ot">=</span> <span class="fu">mask</span>(srtm, zion)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Es importante destacar que, en la mayoría de los casos, se recomienda utilizar conjuntamente las funciones <code>crop()</code> y <code>mask()</code>. Esta combinación de funciones (a) limitaría la extensión del raster a nuestra área de interés y (b) reemplazaría todos los valores fuera del área a NA.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>srtm_cropped <span class="ot">=</span> <span class="fu">crop</span>(srtm, zion)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>srtm_final <span class="ot">=</span> <span class="fu">mask</span>(srtm_cropped, zion)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Cambiando la configuración de <code>mask()</code> se obtienen resultados diferentes. Si se establece <code>inverse = TRUE</code> se enmascarará todo lo que esté <em>dentro</em> de los límites del parque (véase <code>?mask</code> para más detalles), mientras que si se establece <code>updatevalue = 0</code> se pondrán a 0 todos los píxeles fuera del parque nacional.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>srtm_inv_masked <span class="ot">=</span> <span class="fu">mask</span>(srtm, zion, <span class="at">inverse =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-fig.asp="0.36">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="interaccion_raster_vector_files/figure-html/cropmask-1.png" class="img-fluid figure-img" width="960"></p>
<figcaption class="figure-caption">Illustration of raster cropping and raster masking.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="extracción-de-datos-de-un-raster" class="level2">
<h2 class="anchored" data-anchor-id="extracción-de-datos-de-un-raster">Extracción de datos de un raster</h2>
<p>La extracción de raster es el proceso de identificar y devolver los valores asociados a un raster “objetivo” en ubicaciones específicas, basándose en un objeto “selector” geográfico (normalmente vectorial). Los resultados dependen del tipo de selector utilizado (puntos, líneas o polígonos) y de los argumentos pasados a la función <code>terra::extract()</code>. El reverso de la extracción raster — asignar valores de celda raster basado en objetos vectoriales — es la rasterización, que se describe más adelante.</p>
<p>El ejemplo básico consiste en extraer el valor de una celda ráster en <strong>puntos</strong> específicos. Para ello, utilizaremos <code>zion_points</code>, que contiene una muestra de 30 localizaciones dentro del Parque Nacional de Zion. El siguiente comando extrae los valores de elevación de <code>srtm</code> y crea un data frame con los ID de los puntos (un valor por fila del vector) y los valores <code>srtm</code> relacionados para cada punto. Ahora, podemos añadir el objeto resultante a nuestro conjunto de datos <code>zion_points</code> con la función <code>cbind()</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"zion_points"</span>, <span class="at">package =</span> <span class="st">"spDataLarge"</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>elevation <span class="ot">=</span> terra<span class="sc">::</span><span class="fu">extract</span>(srtm, zion_points)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>zion_points <span class="ot">=</span> <span class="fu">cbind</span>(zion_points, elevation)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-fig.asp="0.57">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="interaccion_raster_vector_files/figure-html/pointextr-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Locations of points used for raster extraction.</figcaption>
</figure>
</div>
</div>
</div>
<p>La extracción de datos raster también funciona con selectores de tipo <strong>línea</strong>. Entonces, extrae un valor por cada celda raster tocada por la línea. El enfoque consiste en dividir la línea en muchos puntos y luego extraer los valores de estos puntos. Para demostrarlo, el código siguiente crea <code>zion_transect</code>, una línea recta que va del noroeste al sureste del Parque Nacional de Zion:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>zion_transect <span class="ot">=</span> <span class="fu">cbind</span>(<span class="fu">c</span>(<span class="sc">-</span><span class="fl">113.2</span>, <span class="sc">-</span><span class="fl">112.9</span>), <span class="fu">c</span>(<span class="fl">37.45</span>, <span class="fl">37.2</span>)) <span class="sc">|&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">st_linestring</span>() <span class="sc">|&gt;</span> </span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">st_sfc</span>(<span class="at">crs =</span> <span class="fu">crs</span>(srtm)) <span class="sc">|&gt;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">st_sf</span>(<span class="at">geometry =</span> _)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La utilidad de extraer alturas de un selector lineal se ilustra imaginando que está planeando una excursión. El método que se muestra a continuación proporciona un <code>perfil de elevación</code> de la ruta (no es necesario que la línea sea recta), útil para estimar cuánto tiempo se tardará debido a las subidas.</p>
<p>El primer paso es añadir un <code>id</code> único para cada transecto. A continuación, con la función <code>st_segmentize()</code> podemos añadir puntos a lo largo de nuestra(s) línea(s) con una densidad proporcionada (<code>dfMaxLength</code>) y convertirlos en puntos con <code>st_cast()</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>zion_transect<span class="sc">$</span>id <span class="ot">=</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(zion_transect)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>zion_transect <span class="ot">=</span> <span class="fu">st_segmentize</span>(zion_transect, <span class="at">dfMaxLength =</span> <span class="dv">250</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>zion_transect <span class="ot">=</span> <span class="fu">st_cast</span>(zion_transect, <span class="st">"POINT"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Ahora, tenemos un gran conjunto de puntos, y queremos derivar una distancia entre el primer punto de nuestros transectos y cada uno de los puntos subsiguientes. En este caso, sólo tenemos un transecto, pero el código, en principio, debería funcionar con cualquier número de transectos:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>zion_transect <span class="ot">=</span> zion_transect <span class="sc">|&gt;</span> </span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(id) <span class="sc">|&gt;</span> </span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">dist =</span> <span class="fu">st_distance</span>(geometry)[, <span class="dv">1</span>]) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Por último, podemos extraer los valores de elevación de cada punto de nuestros transectos y combinar esta información con nuestro objeto principal.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>zion_elev <span class="ot">=</span> terra<span class="sc">::</span><span class="fu">extract</span>(srtm, zion_transect)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>zion_transect <span class="ot">=</span> <span class="fu">cbind</span>(zion_transect, zion_elev)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El <code>zion_transect</code> resultante puede utilizarse para crear perfiles de elevación, como se ilustra a continuación.</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="interaccion_raster_vector_files/figure-html/lineextr-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Location of a line used for raster extraction (left) and the elevation along this line (right).</figcaption>
</figure>
</div>
</div>
</div>
<p>El último tipo de objeto vectorial geográfico para la extracción de rásters son los <strong>polígonos</strong>. Al igual que las líneas, los polígonos tienden a devolver muchos valores ráster por polígono. Esto se demuestra en el siguiente comando, que da como resultado un marco de datos con nombres de columna <code>ID</code> (el número de fila del polígono) y <code>srtm</code> (valores de elevación asociados):</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>zion_srtm_values <span class="ot">=</span> terra<span class="sc">::</span><span class="fu">extract</span>(<span class="at">x =</span> srtm, <span class="at">y =</span> zion)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Estos resultados pueden utilizarse para generar estadísticas resumidas de valores ráster por polígono, por ejemplo para caracterizar una única región o para comparar muchas regiones. Esto se muestra en el siguiente código, que crea el objeto <code>zion_srtm_df</code> que contiene estadísticas resumidas para los valores de elevación en el Parque Nacional de Zion:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">group_by</span>(zion_srtm_values, ID) <span class="sc">|&gt;</span> </span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarize</span>(<span class="fu">across</span>(srtm, <span class="fu">list</span>(<span class="at">min =</span> min, <span class="at">mean =</span> mean, <span class="at">max =</span> max)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="kable-table">
<table class="table table-sm table-striped small">
<thead>
<tr class="header">
<th style="text-align: right;">ID</th>
<th style="text-align: right;">srtm_min</th>
<th style="text-align: right;">srtm_mean</th>
<th style="text-align: right;">srtm_max</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: right;">1122</td>
<td style="text-align: right;">1818.212</td>
<td style="text-align: right;">2661</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<p>El trozo de código anterior utilizó <strong>dplyr</strong> para proporcionar estadísticas de resumen para los valores de celda por ID de polígono. Los resultados proporcionan resúmenes útiles, por ejemplo, que la altura máxima en el parque es de alrededor de 2.661 metros sobre el nivel del mar (otras estadísticas de resumen, como la desviación estándar, también se puede calcular de esta manera). Como en el ejemplo sólo hay un polígono, se devuelve una tabla de datos con una única fila; sin embargo, el método funciona cuando se utilizan varios polígonos selectores.</p>
<p>Un método similar funciona para el recuento de ocurrencias de valores ráster categóricos dentro de polígonos. Esto se ilustra con un conjunto de datos de cobertura del suelo (<code>nlcd</code>) del paquete <strong>spDataLarge</strong>, y se demuestra en el código siguiente:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>nlcd <span class="ot">=</span> <span class="fu">rast</span>(<span class="fu">system.file</span>(<span class="st">"raster/nlcd.tif"</span>, <span class="at">package =</span> <span class="st">"spDataLarge"</span>))</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>zion2 <span class="ot">=</span> <span class="fu">st_transform</span>(zion, <span class="fu">st_crs</span>(nlcd))</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>zion_nlcd <span class="ot">=</span> terra<span class="sc">::</span><span class="fu">extract</span>(nlcd, zion2)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>zion_nlcd <span class="sc">|&gt;</span> </span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(ID, levels) <span class="sc">|&gt;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">count</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="kable-table">
<table class="table table-sm table-striped small">
<thead>
<tr class="header">
<th style="text-align: right;">ID</th>
<th style="text-align: left;">levels</th>
<th style="text-align: right;">n</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: left;">Developed</td>
<td style="text-align: right;">4205</td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: left;">Barren</td>
<td style="text-align: right;">98285</td>
</tr>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: left;">Forest</td>
<td style="text-align: right;">298299</td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: left;">Shrubland</td>
<td style="text-align: right;">203700</td>
</tr>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: left;">Herbaceous</td>
<td style="text-align: right;">235</td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: left;">Cultivated</td>
<td style="text-align: right;">62</td>
</tr>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: left;">Wetlands</td>
<td style="text-align: right;">679</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="interaccion_raster_vector_files/figure-html/polyextr-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Area used for continuous (left) and categorical (right) raster extraction.</figcaption>
</figure>
</div>
</div>
</div>
<p>Aunque el paquete <strong>terra</strong> ofrece una rápida extracción de valores ráster dentro de polígonos, <code>extract()</code> puede seguir siendo un cuello de botella cuando se procesan grandes conjuntos de datos de polígonos. El paquete <strong>exactextractr</strong> ofrece una <a href="https://github.com/geocompx/geocompr/issues/813">alternativa significativamente más rápida</a> para extraer valores de píxeles a través de la función <code>exact_extract()</code>. La función <code>exact_extract()</code> también calcula, por defecto, la fracción de cada celda ráster solapada por el polígono, lo cual es más preciso.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Los polígonos suelen tener formas irregulares y, por lo tanto, un polígono puede solapar sólo algunas partes de las celdas de un ráster. Para obtener resultados más detallados, la función <code>terra::extract()</code> tiene un argumento llamado <code>exact</code>. Con <code>exact = TRUE</code>, obtenemos una columna más <code>fraction</code> en el marco de datos de salida, que representa una fracción de cada celda que está cubierta por el polígono. Esto podría ser útil para calcular, por ejemplo, una media ponderada para rásters continuos o una cobertura más precisa para rásters categóricos. Por defecto, es <code>FALSE</code> ya que esta operación requiere más cálculos. La función <code>exactextractr::exact_extract()</code> siempre calcula la fracción de cobertura del polígono en cada celda.</p>
</div>
</div>
</section>
<section id="rasterización" class="level2">
<h2 class="anchored" data-anchor-id="rasterización">Rasterización</h2>
<p>La rasterización es la conversión de objetos vectoriales a raster. Normalmente, el ráster de salida se utiliza después para análisis cuantitativos (por ejemplo, análisis del terreno) o modelado. El proceso de rasterización puede ayudar a simplificar los conjuntos de datos porque todos los valores resultantes tienen la misma resolución espacial: la rasterización puede considerarse un tipo especial de agregación de datos geográficos.</p>
<p>El paquete <strong>terra</strong> contiene la función <code>rasterize()</code> para realizar este trabajo. Sus dos primeros argumentos son, <code>x</code>, objeto vectorial a rasterizar e, <code>y</code>, un objeto `plantilla raster’ que define la extensión, resolución y CRS de la salida. La resolución geográfica del ráster de entrada tiene un gran impacto en los resultados: si es demasiado baja (el tamaño de las celdas es demasiado grande), el resultado puede perder toda la variabilidad geográfica de los datos vectoriales; si es demasiado alta, los tiempos de cálculo pueden ser excesivos. No existen reglas sencillas a la hora de decidir la resolución geográfica adecuada, que depende en gran medida del uso que se pretenda dar a los resultados. A menudo, la resolución objetivo se impone al usuario, por ejemplo cuando el resultado de la rasterización debe alinearse con algún otro raster existente.</p>
<p>Para demostrar la rasterización en acción, utilizaremos una plantilla raster que tiene la misma extensión y CRS que los datos vectoriales de entrada <code>cycle_hire_osm_projected</code> y una resolución espacial de 1000 metros:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>cycle_hire_osm <span class="ot">=</span> spData<span class="sc">::</span>cycle_hire_osm</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>cycle_hire_osm_projected <span class="ot">=</span> <span class="fu">st_transform</span>(cycle_hire_osm, <span class="st">"EPSG:27700"</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>raster_template <span class="ot">=</span> <span class="fu">rast</span>(<span class="fu">ext</span>(cycle_hire_osm_projected), <span class="at">resolution =</span> <span class="dv">1000</span>,</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>                       <span class="at">crs =</span> <span class="fu">st_crs</span>(cycle_hire_osm_projected)<span class="sc">$</span>wkt)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La rasterización es una operación muy flexible: los resultados dependen no sólo de la naturaleza de la plantilla raster, sino también del tipo de vector de entrada (por ejemplo, puntos, polígonos) y de una variedad de argumentos tomados por la función <code>rasterize()</code>.</p>
<p>Para ilustrar esta flexibilidad, probaremos tres enfoques diferentes de la rasterización. En primer lugar, crearemos un raster que represente la presencia o ausencia de puntos de alquiler de bicicletas (conocidos como raster de presencia/ausencia). En este caso, <code>rasterize()</code> no requiere ningún argumento además de <code>x</code> e <code>y</code>, los objetos vector y raster antes mencionados.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>ch_raster1 <span class="ot">=</span> <span class="fu">rasterize</span>(cycle_hire_osm_projected, raster_template)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El argumento <code>fun</code> especifica los estadísticos de resumen utilizados para convertir múltiples observaciones muy próximas en celdas asociadas en el objeto raster. Por defecto se utiliza <code>fun = "last"</code> pero se pueden utilizar otras opciones como <code>fun = "length"</code>, en este caso para contar el número de puntos de alquiler de ciclos en cada celda de la cuadrícula.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>ch_raster2 <span class="ot">=</span> <span class="fu">rasterize</span>(cycle_hire_osm_projected, raster_template, </span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>                       <span class="at">fun =</span> <span class="st">"length"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El nuevo resultado, <code>ch_raster2</code>, muestra el número de puntos de alquiler de bicicletas en cada cuadrícula. Los puntos de alquiler de bicicletas tienen diferentes números de bicicletas descritos por la variable <code>capacity</code>, lo que plantea la siguiente pregunta: ¿cuál es la capacidad de cada celda de la cuadrícula? Para calcularlo debemos “sumar” el campo (<code>"capacity"</code>), calculada con el siguiente comando (también se podrían utilizar otras funciones de resumen como <code>mean</code>):</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>ch_raster3 <span class="ot">=</span> <span class="fu">rasterize</span>(cycle_hire_osm_projected, raster_template, </span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>                       <span class="at">field =</span> <span class="st">"capacity"</span>, <span class="at">fun =</span> sum, <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="interaccion_raster_vector_files/figure-html/vector-rasterization1-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Examples of point rasterization.</figcaption>
</figure>
</div>
</div>
</div>
<p>Otro conjunto de datos basado en polígonos y fronteras de California ilustra la rasterización de líneas. Tras fundir los objetos poligonales en una multilínea, se crea un raster de plantilla con una resolución de 0.5 grados:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(spData)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>california <span class="ot">=</span> dplyr<span class="sc">::</span><span class="fu">filter</span>(us_states, NAME <span class="sc">==</span> <span class="st">"California"</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>california_borders <span class="ot">=</span> <span class="fu">st_cast</span>(california, <span class="st">"MULTILINESTRING"</span>)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>raster_template2 <span class="ot">=</span> <span class="fu">rast</span>(<span class="fu">ext</span>(california), <span class="at">resolution =</span> <span class="fl">0.5</span>,</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>                        <span class="at">crs =</span> <span class="fu">st_crs</span>(california)<span class="sc">$</span>wkt)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Al considerar la rasterización de líneas o polígonos, un argumento adicional útil es “touches”. Por defecto es <code>FALSE</code>, pero cuando se cambia a <code>TRUE</code> – todas las celdas que son tocadas por el borde de una línea o polígono obtienen un valor. La rasterización de líneas con <code>touches = TRUE</code> se muestra en el siguiente código.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>california_raster1 <span class="ot">=</span> <span class="fu">rasterize</span>(california_borders, raster_template2,</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>                               <span class="at">touches =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Compárelo con una rasterización de polígonos, con <code>touches = FALSE</code> por defecto, que selecciona sólo las celdas raster cuyos centroides están dentro del polígono selector.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>california_raster2 <span class="ot">=</span> <span class="fu">rasterize</span>(california, raster_template2) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="interaccion_raster_vector_files/figure-html/vector-rasterization2-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Examples of line and polygon rasterizations.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="vectorización-espacial" class="level2">
<h2 class="anchored" data-anchor-id="vectorización-espacial">Vectorización espacial</h2>
<p>La vectorización espacial es la contrapartida de la rasterización. Consiste en convertir datos ráster espacialmente continuos en datos vectoriales espacialmente discretos, como puntos, líneas o polígonos.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>En R, la vectorización suele referirse a la posibilidad de sustituir los bucles <code>for</code> y similares haciendo cosas como <code>1:10 / 2</code>.</p>
</div>
</div>
<p>La forma más simple de vectorización es convertir los centroides de las celdas raster en puntos. <code>as.points()</code> hace exactamente esto para todas las celdas de cuadrícula raster que no sean <code>NA</code>. Tenga en cuenta que aquí también utilizamos <code>st_as_sf()</code> para convertir el objeto resultante a la clase <code>sf</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>elev <span class="ot">=</span> <span class="fu">rast</span>(<span class="fu">system.file</span>(<span class="st">"raster/elev.tif"</span>, <span class="at">package =</span> <span class="st">"spData"</span>))</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>elev_point <span class="ot">=</span> <span class="fu">as.points</span>(elev) <span class="sc">|&gt;</span> </span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">st_as_sf</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="interaccion_raster_vector_files/figure-html/raster-vectorization1-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Raster and point representation of the elev object.</figcaption>
</figure>
</div>
</div>
</div>
<p>Otro tipo común de vectorización espacial es la creación de curvas de nivel que representen líneas de altura o temperaturas continuas (isotermas), por ejemplo. Utilizaremos un modelo digital de elevación (MDE) del mundo real porque el ráster artificial <code>elev</code> produce líneas paralelas. Las curvas de nivel se pueden crear con la función <strong>terra</strong> <code>as.contour()</code>, que es a su vez una envoltura de la función incorporada en R <code>filled.contour()</code>, como se demuestra a continuación:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>dem <span class="ot">=</span> <span class="fu">rast</span>(<span class="fu">system.file</span>(<span class="st">"raster/dem.tif"</span>, <span class="at">package =</span> <span class="st">"spDataLarge"</span>))</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>cl <span class="ot">=</span> <span class="fu">as.contour</span>(dem) <span class="sc">|&gt;</span> </span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">st_as_sf</span>()</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(dem, <span class="at">axes =</span> <span class="cn">FALSE</span>)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(cl, <span class="at">add =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="interaccion_raster_vector_files/figure-html/06-raster-vector-36-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>También pueden añadirse contornos a los gráficos existentes con funciones como <code>contour()</code>, <code>rasterVis::contourplot()</code> o <code>tmap::tm_iso()</code> y, las isolíneas pueden etiquetarse.</p>
<div class="cell" data-fig.asp="0.56">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="interaccion_raster_vector_files/figure-html/contour-tmap-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">DEM with hillshading, showing the southern flank of Mt. Mongón overlaid with contour lines.</figcaption>
</figure>
</div>
</div>
</div>
<p>El último tipo de vectorización implica la conversión de rásters en polígonos. Esto puede hacerse con <code>terra::as.polygons()</code>, que convierte cada celda ráster en un polígono formado por cinco coordenadas, todas las cuales se almacenan en memoria (¡explicando por qué los rásters son a menudo rápidos comparados con los vectores!).</p>
<p>Esto se ilustra a continuación convirtiendo el objeto <code>grain</code> en polígonos y disolviendo posteriormente los bordes entre polígonos con los mismos valores de atributo (véase también el argumento <code>dissolve</code> en <code>as.polygons()</code>).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>grain <span class="ot">=</span> <span class="fu">rast</span>(<span class="fu">system.file</span>(<span class="st">"raster/grain.tif"</span>, <span class="at">package =</span> <span class="st">"spData"</span>))</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>grain_poly <span class="ot">=</span> <span class="fu">as.polygons</span>(grain) <span class="sc">|&gt;</span> </span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">st_as_sf</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-fig.asp="0.4">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="interaccion_raster_vector_files/figure-html/06-raster-vector-40-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Illustration of vectorization of raster (left) into polygons (dissolve = FALSE; center) and aggregated polygons (dissolve = TRUE; right).</figcaption>
</figure>
</div>
</div>
</div>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>